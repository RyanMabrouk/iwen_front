{"version":3,"file":"6327.js","mappings":"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","sources":["webpack://iwan-front/ignored|/Users/macmini/Sites/iwan/iwen_front/node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib|bufferutil","webpack://iwan-front/ignored|/Users/macmini/Sites/iwan/iwen_front/node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib|utf-8-validate","webpack://iwan-front/./node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/buffer-util.js","webpack://iwan-front/./node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/constants.js","webpack://iwan-front/./node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/event-target.js","webpack://iwan-front/./node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/extension.js","webpack://iwan-front/./node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/limiter.js","webpack://iwan-front/./node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/permessage-deflate.js","webpack://iwan-front/./node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/receiver.js","webpack://iwan-front/./node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/sender.js","webpack://iwan-front/./node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/stream.js","webpack://iwan-front/./node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/subprotocol.js","webpack://iwan-front/./node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/validation.js","webpack://iwan-front/./node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/websocket-server.js","webpack://iwan-front/./node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/websocket.js","webpack://iwan-front/./node_modules/.pnpm/ws@8.18.0/node_modules/ws/wrapper.mjs"],"sourcesContent":["/* (ignored) */","/* (ignored) */","'use strict';\n\nconst { EMPTY_BUFFER } = require('./constants');\n\nconst FastBuffer = Buffer[Symbol.species];\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n\n  if (offset < totalLength) {\n    return new FastBuffer(target.buffer, target.byteOffset, offset);\n  }\n\n  return target;\n}\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nfunction _mask(source, mask, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nfunction _unmask(buffer, mask) {\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\nfunction toArrayBuffer(buf) {\n  if (buf.length === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\n}\n\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n\n  if (Buffer.isBuffer(data)) return data;\n\n  let buf;\n\n  if (data instanceof ArrayBuffer) {\n    buf = new FastBuffer(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n\n  return buf;\n}\n\nmodule.exports = {\n  concat,\n  mask: _mask,\n  toArrayBuffer,\n  toBuffer,\n  unmask: _unmask\n};\n\n/* istanbul ignore else  */\nif (!process.env.WS_NO_BUFFER_UTIL) {\n  try {\n    const bufferUtil = require('bufferutil');\n\n    module.exports.mask = function (source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);\n      else bufferUtil.mask(source, mask, output, offset, length);\n    };\n\n    module.exports.unmask = function (buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);\n      else bufferUtil.unmask(buffer, mask);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}\n","'use strict';\n\nconst BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];\nconst hasBlob = typeof Blob !== 'undefined';\n\nif (hasBlob) BINARY_TYPES.push('blob');\n\nmodule.exports = {\n  BINARY_TYPES,\n  EMPTY_BUFFER: Buffer.alloc(0),\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n  hasBlob,\n  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),\n  kListener: Symbol('kListener'),\n  kStatusCode: Symbol('status-code'),\n  kWebSocket: Symbol('websocket'),\n  NOOP: () => {}\n};\n","'use strict';\n\nconst { kForOnEventAttribute, kListener } = require('./constants');\n\nconst kCode = Symbol('kCode');\nconst kData = Symbol('kData');\nconst kError = Symbol('kError');\nconst kMessage = Symbol('kMessage');\nconst kReason = Symbol('kReason');\nconst kTarget = Symbol('kTarget');\nconst kType = Symbol('kType');\nconst kWasClean = Symbol('kWasClean');\n\n/**\n * Class representing an event.\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n\n  /**\n   * @type {*}\n   */\n  get target() {\n    return this[kTarget];\n  }\n\n  /**\n   * @type {String}\n   */\n  get type() {\n    return this[kType];\n  }\n}\n\nObject.defineProperty(Event.prototype, 'target', { enumerable: true });\nObject.defineProperty(Event.prototype, 'type', { enumerable: true });\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kCode] = options.code === undefined ? 0 : options.code;\n    this[kReason] = options.reason === undefined ? '' : options.reason;\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get code() {\n    return this[kCode];\n  }\n\n  /**\n   * @type {String}\n   */\n  get reason() {\n    return this[kReason];\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get wasClean() {\n    return this[kWasClean];\n  }\n}\n\nObject.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kError] = options.error === undefined ? null : options.error;\n    this[kMessage] = options.message === undefined ? '' : options.message;\n  }\n\n  /**\n   * @type {*}\n   */\n  get error() {\n    return this[kError];\n  }\n\n  /**\n   * @type {String}\n   */\n  get message() {\n    return this[kMessage];\n  }\n}\n\nObject.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });\nObject.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kData] = options.data === undefined ? null : options.data;\n  }\n\n  /**\n   * @type {*}\n   */\n  get data() {\n    return this[kData];\n  }\n}\n\nObject.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {(Function|Object)} handler The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, handler, options = {}) {\n    for (const listener of this.listeners(type)) {\n      if (\n        !options[kForOnEventAttribute] &&\n        listener[kListener] === handler &&\n        !listener[kForOnEventAttribute]\n      ) {\n        return;\n      }\n    }\n\n    let wrapper;\n\n    if (type === 'message') {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent('message', {\n          data: isBinary ? data : data.toString()\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'close') {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent('close', {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'error') {\n      wrapper = function onError(error) {\n        const event = new ErrorEvent('error', {\n          error,\n          message: error.message\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'open') {\n      wrapper = function onOpen() {\n        const event = new Event('open');\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else {\n      return;\n    }\n\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n    wrapper[kListener] = handler;\n\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {(Function|Object)} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n};\n\nmodule.exports = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};\n\n/**\n * Call an event listener\n *\n * @param {(Function|Object)} listener The listener to call\n * @param {*} thisArg The value to use as `this`` when calling the listener\n * @param {Event} event The event to pass to the listener\n * @private\n */\nfunction callListener(listener, thisArg, event) {\n  if (typeof listener === 'object' && listener.handleEvent) {\n    listener.handleEvent.call(listener, event);\n  } else {\n    listener.call(thisArg, event);\n  }\n}\n","'use strict';\n\nconst { tokenChars } = require('./validation');\n\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\nfunction push(dest, name, elem) {\n  if (dest[name] === undefined) dest[name] = [elem];\n  else dest[name].push(elem);\n}\n\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\nfunction parse(header) {\n  const offers = Object.create(null);\n  let params = Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let code = -1;\n  let end = -1;\n  let i = 0;\n\n  for (; i < header.length; i++) {\n    code = header.charCodeAt(i);\n\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (\n        i !== 0 &&\n        (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\n      ) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 0x2c) {\n          push(offers, name, params);\n          params = Object.create(null);\n        } else {\n          extensionName = name;\n        }\n\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        start = end = -1;\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;\n        else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c /* '\\' */) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        let value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n\n  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === undefined) {\n    push(offers, token, params);\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n\n  return offers;\n}\n\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */\nfunction format(extensions) {\n  return Object.keys(extensions)\n    .map((extension) => {\n      let configurations = extensions[extension];\n      if (!Array.isArray(configurations)) configurations = [configurations];\n      return configurations\n        .map((params) => {\n          return [extension]\n            .concat(\n              Object.keys(params).map((k) => {\n                let values = params[k];\n                if (!Array.isArray(values)) values = [values];\n                return values\n                  .map((v) => (v === true ? k : `${k}=${v}`))\n                  .join('; ');\n              })\n            )\n            .join('; ');\n        })\n        .join(', ');\n    })\n    .join(', ');\n}\n\nmodule.exports = { format, parse };\n","'use strict';\n\nconst kDone = Symbol('kDone');\nconst kRun = Symbol('kRun');\n\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */\nclass Limiter {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n\n  /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n  [kRun]() {\n    if (this.pending === this.concurrency) return;\n\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n}\n\nmodule.exports = Limiter;\n","'use strict';\n\nconst zlib = require('zlib');\n\nconst bufferUtil = require('./buffer-util');\nconst Limiter = require('./limiter');\nconst { kStatusCode } = require('./constants');\n\nconst FastBuffer = Buffer[Symbol.species];\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst kPerMessageDeflate = Symbol('permessage-deflate');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\n\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n\n/**\n * permessage-deflate implementation.\n */\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed if context takeover is disabled\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold =\n      this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency =\n        this._options.concurrencyLimit !== undefined\n          ? this._options.concurrencyLimit\n          : 10;\n      zlibLimiter = new Limiter(concurrency);\n    }\n  }\n\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n\n    this.params = this._isServer\n      ? this.acceptAsServer(configurations)\n      : this.acceptAsClient(configurations);\n\n    return this.params;\n  }\n\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n\n    if (this._deflate) {\n      const callback = this._deflate[kCallback];\n\n      this._deflate.close();\n      this._deflate = null;\n\n      if (callback) {\n        callback(\n          new Error(\n            'The deflate stream was closed while data was being processed'\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find((params) => {\n      if (\n        (opts.serverNoContextTakeover === false &&\n          params.server_no_context_takeover) ||\n        (params.server_max_window_bits &&\n          (opts.serverMaxWindowBits === false ||\n            (typeof opts.serverMaxWindowBits === 'number' &&\n              opts.serverMaxWindowBits > params.server_max_window_bits))) ||\n        (typeof opts.clientMaxWindowBits === 'number' &&\n          !params.client_max_window_bits)\n      ) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!accepted) {\n      throw new Error('None of the extension offers can be accepted');\n    }\n\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (\n      accepted.client_max_window_bits === true ||\n      opts.clientMaxWindowBits === false\n    ) {\n      delete accepted.client_max_window_bits;\n    }\n\n    return accepted;\n  }\n\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n\n    if (\n      this._options.clientNoContextTakeover === false &&\n      params.client_no_context_takeover\n    ) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (\n      this._options.clientMaxWindowBits === false ||\n      (typeof this._options.clientMaxWindowBits === 'number' &&\n        params.client_max_window_bits > this._options.clientMaxWindowBits)\n    ) {\n      throw new Error(\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\n      );\n    }\n\n    return params;\n  }\n\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach((params) => {\n      Object.keys(params).forEach((key) => {\n        let value = params[key];\n\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n\n        value = value[0];\n\n        if (key === 'client_max_window_bits') {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(\n                `Invalid value for parameter \"${key}\": ${value}`\n              );\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else if (key === 'server_max_window_bits') {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n          value = num;\n        } else if (\n          key === 'client_no_context_takeover' ||\n          key === 'server_no_context_takeover'\n        ) {\n          if (value !== true) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n\n        params[key] = value;\n      });\n    });\n\n    return configurations;\n  }\n\n  /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._inflate = zlib.createInflateRaw({\n        ...this._options.zlibInflateOptions,\n        windowBits\n      });\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on('error', inflateOnError);\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(\n        this._inflate[kBuffers],\n        this._inflate[kTotalLength]\n      );\n\n      if (this._inflate._readableState.endEmitted) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n          this._inflate.reset();\n        }\n      }\n\n      callback(null, data);\n    });\n  }\n\n  /**\n   * Compress data.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._deflate = zlib.createDeflateRaw({\n        ...this._options.zlibDeflateOptions,\n        windowBits\n      });\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate[kCallback] = callback;\n\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        //\n        // The deflate stream was closed while data was being processed.\n        //\n        return;\n      }\n\n      let data = bufferUtil.concat(\n        this._deflate[kBuffers],\n        this._deflate[kTotalLength]\n      );\n\n      if (fin) {\n        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);\n      }\n\n      //\n      // Ensure that the callback will not be called again in\n      // `PerMessageDeflate#cleanup()`.\n      //\n      this._deflate[kCallback] = null;\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.reset();\n      }\n\n      callback(null, data);\n    });\n  }\n}\n\nmodule.exports = PerMessageDeflate;\n\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (\n    this[kPerMessageDeflate]._maxPayload < 1 ||\n    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\n  ) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new RangeError('Max payload size exceeded');\n  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';\n  this[kError][kStatusCode] = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode] = 1007;\n  this[kCallback](err);\n}\n","'use strict';\n\nconst { Writable } = require('stream');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = require('./constants');\nconst { concat, toArrayBuffer, unmask } = require('./buffer-util');\nconst { isValidStatusCode, isValidUTF8 } = require('./validation');\n\nconst FastBuffer = Buffer[Symbol.species];\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\nconst DEFER_EVENT = 6;\n\n/**\n * HyBi Receiver implementation.\n *\n * @extends Writable\n */\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */\n  constructor(options = {}) {\n    super();\n\n    this._allowSynchronousEvents =\n      options.allowSynchronousEvents !== undefined\n        ? options.allowSynchronousEvents\n        : true;\n    this._binaryType = options.binaryType || BINARY_TYPES[0];\n    this._extensions = options.extensions || {};\n    this._isServer = !!options.isServer;\n    this._maxPayload = options.maxPayload | 0;\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\n    this[kWebSocket] = undefined;\n\n    this._bufferedBytes = 0;\n    this._buffers = [];\n\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n\n    this._errored = false;\n    this._loop = false;\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n\n    if (n === this._buffers[0].length) return this._buffers.shift();\n\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = new FastBuffer(\n        buf.buffer,\n        buf.byteOffset + n,\n        buf.length - n\n      );\n\n      return new FastBuffer(buf.buffer, buf.byteOffset, n);\n    }\n\n    const dst = Buffer.allocUnsafe(n);\n\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = new FastBuffer(\n          buf.buffer,\n          buf.byteOffset + n,\n          buf.length - n\n        );\n      }\n\n      n -= buf.length;\n    } while (n > 0);\n\n    return dst;\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    this._loop = true;\n\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          this.getInfo(cb);\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          this.getPayloadLength16(cb);\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          this.getPayloadLength64(cb);\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          this.getData(cb);\n          break;\n        case INFLATING:\n        case DEFER_EVENT:\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n\n    if (!this._errored) cb();\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getInfo(cb) {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      const error = this.createError(\n        RangeError,\n        'RSV2 and RSV3 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_2_3'\n      );\n\n      cb(error);\n      return;\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      const error = this.createError(\n        RangeError,\n        'RSV1 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_1'\n      );\n\n      cb(error);\n      return;\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        const error = this.createError(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (!this._fragmented) {\n        const error = this.createError(\n          RangeError,\n          'invalid opcode 0',\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n\n        cb(error);\n        return;\n      }\n\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        const error = this.createError(\n          RangeError,\n          `invalid opcode ${this._opcode}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n\n        cb(error);\n        return;\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        const error = this.createError(\n          RangeError,\n          'FIN must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_FIN'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (compressed) {\n        const error = this.createError(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (\n        this._payloadLength > 0x7d ||\n        (this._opcode === 0x08 && this._payloadLength === 1)\n      ) {\n        const error = this.createError(\n          RangeError,\n          `invalid payload length ${this._payloadLength}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'\n        );\n\n        cb(error);\n        return;\n      }\n    } else {\n      const error = this.createError(\n        RangeError,\n        `invalid opcode ${this._opcode}`,\n        true,\n        1002,\n        'WS_ERR_INVALID_OPCODE'\n      );\n\n      cb(error);\n      return;\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._isServer) {\n      if (!this._masked) {\n        const error = this.createError(\n          RangeError,\n          'MASK must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_MASK'\n        );\n\n        cb(error);\n        return;\n      }\n    } else if (this._masked) {\n      const error = this.createError(\n        RangeError,\n        'MASK must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_MASK'\n      );\n\n      cb(error);\n      return;\n    }\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n    else this.haveLength(cb);\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getPayloadLength16(cb) {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    this.haveLength(cb);\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getPayloadLength64(cb) {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      const error = this.createError(\n        RangeError,\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\n        false,\n        1009,\n        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'\n      );\n\n      cb(error);\n      return;\n    }\n\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    this.haveLength(cb);\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  haveLength(cb) {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        const error = this.createError(\n          RangeError,\n          'Max payload size exceeded',\n          false,\n          1009,\n          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n        );\n\n        cb(error);\n        return;\n      }\n    }\n\n    if (this._masked) this._state = GET_MASK;\n    else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n\n      data = this.consume(this._payloadLength);\n\n      if (\n        this._masked &&\n        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0\n      ) {\n        unmask(data, this._mask);\n      }\n    }\n\n    if (this._opcode > 0x07) {\n      this.controlMessage(data, cb);\n      return;\n    }\n\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n\n    if (data.length) {\n      //\n      // This message is not compressed so its length is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n\n    this.dataMessage(cb);\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          const error = this.createError(\n            RangeError,\n            'Max payload size exceeded',\n            false,\n            1009,\n            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n          );\n\n          cb(error);\n          return;\n        }\n\n        this._fragments.push(buf);\n      }\n\n      this.dataMessage(cb);\n      if (this._state === GET_INFO) this.startLoop(cb);\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  dataMessage(cb) {\n    if (!this._fin) {\n      this._state = GET_INFO;\n      return;\n    }\n\n    const messageLength = this._messageLength;\n    const fragments = this._fragments;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragmented = 0;\n    this._fragments = [];\n\n    if (this._opcode === 2) {\n      let data;\n\n      if (this._binaryType === 'nodebuffer') {\n        data = concat(fragments, messageLength);\n      } else if (this._binaryType === 'arraybuffer') {\n        data = toArrayBuffer(concat(fragments, messageLength));\n      } else if (this._binaryType === 'blob') {\n        data = new Blob(fragments);\n      } else {\n        data = fragments;\n      }\n\n      if (this._allowSynchronousEvents) {\n        this.emit('message', data, true);\n        this._state = GET_INFO;\n      } else {\n        this._state = DEFER_EVENT;\n        setImmediate(() => {\n          this.emit('message', data, true);\n          this._state = GET_INFO;\n          this.startLoop(cb);\n        });\n      }\n    } else {\n      const buf = concat(fragments, messageLength);\n\n      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n        const error = this.createError(\n          Error,\n          'invalid UTF-8 sequence',\n          true,\n          1007,\n          'WS_ERR_INVALID_UTF8'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (this._state === INFLATING || this._allowSynchronousEvents) {\n        this.emit('message', buf, false);\n        this._state = GET_INFO;\n      } else {\n        this._state = DEFER_EVENT;\n        setImmediate(() => {\n          this.emit('message', buf, false);\n          this._state = GET_INFO;\n          this.startLoop(cb);\n        });\n      }\n    }\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data, cb) {\n    if (this._opcode === 0x08) {\n      if (data.length === 0) {\n        this._loop = false;\n        this.emit('conclude', 1005, EMPTY_BUFFER);\n        this.end();\n      } else {\n        const code = data.readUInt16BE(0);\n\n        if (!isValidStatusCode(code)) {\n          const error = this.createError(\n            RangeError,\n            `invalid status code ${code}`,\n            true,\n            1002,\n            'WS_ERR_INVALID_CLOSE_CODE'\n          );\n\n          cb(error);\n          return;\n        }\n\n        const buf = new FastBuffer(\n          data.buffer,\n          data.byteOffset + 2,\n          data.length - 2\n        );\n\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          const error = this.createError(\n            Error,\n            'invalid UTF-8 sequence',\n            true,\n            1007,\n            'WS_ERR_INVALID_UTF8'\n          );\n\n          cb(error);\n          return;\n        }\n\n        this._loop = false;\n        this.emit('conclude', code, buf);\n        this.end();\n      }\n\n      this._state = GET_INFO;\n      return;\n    }\n\n    if (this._allowSynchronousEvents) {\n      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\n      this._state = GET_INFO;\n    } else {\n      this._state = DEFER_EVENT;\n      setImmediate(() => {\n        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\n        this._state = GET_INFO;\n        this.startLoop(cb);\n      });\n    }\n  }\n\n  /**\n   * Builds an error object.\n   *\n   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n   * @param {String} message The error message\n   * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n   *     `message`\n   * @param {Number} statusCode The status code\n   * @param {String} errorCode The exposed error code\n   * @return {(Error|RangeError)} The error\n   * @private\n   */\n  createError(ErrorCtor, message, prefix, statusCode, errorCode) {\n    this._loop = false;\n    this._errored = true;\n\n    const err = new ErrorCtor(\n      prefix ? `Invalid WebSocket frame: ${message}` : message\n    );\n\n    Error.captureStackTrace(err, this.createError);\n    err.code = errorCode;\n    err[kStatusCode] = statusCode;\n    return err;\n  }\n}\n\nmodule.exports = Receiver;\n","/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex\" }] */\n\n'use strict';\n\nconst { Duplex } = require('stream');\nconst { randomFillSync } = require('crypto');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst { EMPTY_BUFFER, kWebSocket, NOOP } = require('./constants');\nconst { isBlob, isValidStatusCode } = require('./validation');\nconst { mask: applyMask, toBuffer } = require('./buffer-util');\n\nconst kByteLength = Symbol('kByteLength');\nconst maskBuffer = Buffer.alloc(4);\nconst RANDOM_POOL_SIZE = 8 * 1024;\nlet randomPool;\nlet randomPoolPointer = RANDOM_POOL_SIZE;\n\nconst DEFAULT = 0;\nconst DEFLATING = 1;\nconst GET_BLOB_DATA = 2;\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {Duplex} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */\n  constructor(socket, extensions, generateMask) {\n    this._extensions = extensions || {};\n\n    if (generateMask) {\n      this._generateMask = generateMask;\n      this._maskBuffer = Buffer.alloc(4);\n    }\n\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._queue = [];\n    this._state = DEFAULT;\n    this.onerror = NOOP;\n    this[kWebSocket] = undefined;\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */\n  static frame(data, options) {\n    let mask;\n    let merge = false;\n    let offset = 2;\n    let skipMasking = false;\n\n    if (options.mask) {\n      mask = options.maskBuffer || maskBuffer;\n\n      if (options.generateMask) {\n        options.generateMask(mask);\n      } else {\n        if (randomPoolPointer === RANDOM_POOL_SIZE) {\n          /* istanbul ignore else  */\n          if (randomPool === undefined) {\n            //\n            // This is lazily initialized because server-sent frames must not\n            // be masked so it may never be used.\n            //\n            randomPool = Buffer.alloc(RANDOM_POOL_SIZE);\n          }\n\n          randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);\n          randomPoolPointer = 0;\n        }\n\n        mask[0] = randomPool[randomPoolPointer++];\n        mask[1] = randomPool[randomPoolPointer++];\n        mask[2] = randomPool[randomPoolPointer++];\n        mask[3] = randomPool[randomPoolPointer++];\n      }\n\n      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n      offset = 6;\n    }\n\n    let dataLength;\n\n    if (typeof data === 'string') {\n      if (\n        (!options.mask || skipMasking) &&\n        options[kByteLength] !== undefined\n      ) {\n        dataLength = options[kByteLength];\n      } else {\n        data = Buffer.from(data);\n        dataLength = data.length;\n      }\n    } else {\n      dataLength = data.length;\n      merge = options.mask && options.readOnly && !skipMasking;\n    }\n\n    let payloadLength = dataLength;\n\n    if (dataLength >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (dataLength > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(dataLength, 2);\n    } else if (payloadLength === 127) {\n      target[2] = target[3] = 0;\n      target.writeUIntBE(dataLength, 4, 6);\n    }\n\n    if (!options.mask) return [target, data];\n\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (skipMasking) return [target, data];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, dataLength);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, dataLength);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  close(code, data, mask, cb) {\n    let buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || !data.length) {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n\n      if (length > 123) {\n        throw new RangeError('The message must not be greater than 123 bytes');\n      }\n\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n\n      if (typeof data === 'string') {\n        buf.write(data, 2);\n      } else {\n        buf.set(data, 2);\n      }\n    }\n\n    const options = {\n      [kByteLength]: buf.length,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x08,\n      readOnly: false,\n      rsv1: false\n    };\n\n    if (this._state !== DEFAULT) {\n      this.enqueue([this.dispatch, buf, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(buf, options), cb);\n    }\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  ping(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else if (isBlob(data)) {\n      byteLength = data.size;\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x09,\n      readOnly,\n      rsv1: false\n    };\n\n    if (isBlob(data)) {\n      if (this._state !== DEFAULT) {\n        this.enqueue([this.getBlobData, data, false, options, cb]);\n      } else {\n        this.getBlobData(data, false, options, cb);\n      }\n    } else if (this._state !== DEFAULT) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  pong(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else if (isBlob(data)) {\n      byteLength = data.size;\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x0a,\n      readOnly,\n      rsv1: false\n    };\n\n    if (isBlob(data)) {\n      if (this._state !== DEFAULT) {\n        this.enqueue([this.getBlobData, data, false, options, cb]);\n      } else {\n        this.getBlobData(data, false, options, cb);\n      }\n    } else if (this._state !== DEFAULT) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else if (isBlob(data)) {\n      byteLength = data.size;\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (\n        rsv1 &&\n        perMessageDeflate &&\n        perMessageDeflate.params[\n          perMessageDeflate._isServer\n            ? 'server_no_context_takeover'\n            : 'client_no_context_takeover'\n        ]\n      ) {\n        rsv1 = byteLength >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    const opts = {\n      [kByteLength]: byteLength,\n      fin: options.fin,\n      generateMask: this._generateMask,\n      mask: options.mask,\n      maskBuffer: this._maskBuffer,\n      opcode,\n      readOnly,\n      rsv1\n    };\n\n    if (isBlob(data)) {\n      if (this._state !== DEFAULT) {\n        this.enqueue([this.getBlobData, data, this._compress, opts, cb]);\n      } else {\n        this.getBlobData(data, this._compress, opts, cb);\n      }\n    } else if (this._state !== DEFAULT) {\n      this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n    } else {\n      this.dispatch(data, this._compress, opts, cb);\n    }\n  }\n\n  /**\n   * Gets the contents of a blob as binary data.\n   *\n   * @param {Blob} blob The blob\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     the data\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  getBlobData(blob, compress, options, cb) {\n    this._bufferedBytes += options[kByteLength];\n    this._state = GET_BLOB_DATA;\n\n    blob\n      .arrayBuffer()\n      .then((arrayBuffer) => {\n        if (this._socket.destroyed) {\n          const err = new Error(\n            'The socket was closed while the blob was being read'\n          );\n\n          //\n          // `callCallbacks` is called in the next tick to ensure that errors\n          // that might be thrown in the callbacks behave like errors thrown\n          // outside the promise chain.\n          //\n          process.nextTick(callCallbacks, this, err, cb);\n          return;\n        }\n\n        this._bufferedBytes -= options[kByteLength];\n        const data = toBuffer(arrayBuffer);\n\n        if (!compress) {\n          this._state = DEFAULT;\n          this.sendFrame(Sender.frame(data, options), cb);\n          this.dequeue();\n        } else {\n          this.dispatch(data, compress, options, cb);\n        }\n      })\n      .catch((err) => {\n        //\n        // `onError` is called in the next tick for the same reason that\n        // `callCallbacks` above is.\n        //\n        process.nextTick(onError, this, err, cb);\n      });\n  }\n\n  /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._bufferedBytes += options[kByteLength];\n    this._state = DEFLATING;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error(\n          'The socket was closed while data was being compressed'\n        );\n\n        callCallbacks(this, err, cb);\n        return;\n      }\n\n      this._bufferedBytes -= options[kByteLength];\n      this._state = DEFAULT;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (this._state === DEFAULT && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[3][kByteLength];\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[3][kByteLength];\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n\n/**\n * Calls queued callbacks with an error.\n *\n * @param {Sender} sender The `Sender` instance\n * @param {Error} err The error to call the callbacks with\n * @param {Function} [cb] The first callback\n * @private\n */\nfunction callCallbacks(sender, err, cb) {\n  if (typeof cb === 'function') cb(err);\n\n  for (let i = 0; i < sender._queue.length; i++) {\n    const params = sender._queue[i];\n    const callback = params[params.length - 1];\n\n    if (typeof callback === 'function') callback(err);\n  }\n}\n\n/**\n * Handles a `Sender` error.\n *\n * @param {Sender} sender The `Sender` instance\n * @param {Error} err The error\n * @param {Function} [cb] The first pending callback\n * @private\n */\nfunction onError(sender, err, cb) {\n  callCallbacks(sender, err, cb);\n  sender.onerror(err);\n}\n","'use strict';\n\nconst { Duplex } = require('stream');\n\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */\nfunction emitClose(stream) {\n  stream.emit('close');\n}\n\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\n\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */\nfunction duplexOnError(err) {\n  this.removeListener('error', duplexOnError);\n  this.destroy();\n  if (this.listenerCount('error') === 0) {\n    // Do not suppress the throwing behavior.\n    this.emit('error', err);\n  }\n}\n\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */\nfunction createWebSocketStream(ws, options) {\n  let terminateOnDestroy = true;\n\n  const duplex = new Duplex({\n    ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n\n  ws.on('message', function message(msg, isBinary) {\n    const data =\n      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n\n    if (!duplex.push(data)) ws.pause();\n  });\n\n  ws.once('error', function error(err) {\n    if (duplex.destroyed) return;\n\n    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n    //\n    // - If the `'error'` event is emitted before the `'open'` event, then\n    //   `ws.terminate()` is a noop as no socket is assigned.\n    // - Otherwise, the error is re-emitted by the listener of the `'error'`\n    //   event of the `Receiver` object. The listener already closes the\n    //   connection by calling `ws.close()`. This allows a close frame to be\n    //   sent to the other peer. If `ws.terminate()` is called right after this,\n    //   then the close frame might not be sent.\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n\n  ws.once('close', function close() {\n    if (duplex.destroyed) return;\n\n    duplex.push(null);\n  });\n\n  duplex._destroy = function (err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n      return;\n    }\n\n    let called = false;\n\n    ws.once('error', function error(err) {\n      called = true;\n      callback(err);\n    });\n\n    ws.once('close', function close() {\n      if (!called) callback(err);\n      process.nextTick(emitClose, duplex);\n    });\n\n    if (terminateOnDestroy) ws.terminate();\n  };\n\n  duplex._final = function (callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n\n    // If the value of the `_socket` property is `null` it means that `ws` is a\n    // client websocket and the handshake failed. In fact, when this happens, a\n    // socket is never assigned to the websocket. Wait for the `'error'` event\n    // that will be emitted by the websocket.\n    if (ws._socket === null) return;\n\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted) duplex.destroy();\n    } else {\n      ws._socket.once('finish', function finish() {\n        // `duplex` is not destroyed here because the `'end'` event will be\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n        callback();\n      });\n      ws.close();\n    }\n  };\n\n  duplex._read = function () {\n    if (ws.isPaused) ws.resume();\n  };\n\n  duplex._write = function (chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n\n    ws.send(chunk, callback);\n  };\n\n  duplex.on('end', duplexOnEnd);\n  duplex.on('error', duplexOnError);\n  return duplex;\n}\n\nmodule.exports = createWebSocketStream;\n","'use strict';\n\nconst { tokenChars } = require('./validation');\n\n/**\n * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\n *\n * @param {String} header The field value of the header\n * @return {Set} The subprotocol names\n * @public\n */\nfunction parse(header) {\n  const protocols = new Set();\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (i; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n\n    if (end === -1 && tokenChars[code] === 1) {\n      if (start === -1) start = i;\n    } else if (\n      i !== 0 &&\n      (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\n    ) {\n      if (end === -1 && start !== -1) end = i;\n    } else if (code === 0x2c /* ',' */) {\n      if (start === -1) {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n\n      if (end === -1) end = i;\n\n      const protocol = header.slice(start, end);\n\n      if (protocols.has(protocol)) {\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n      }\n\n      protocols.add(protocol);\n      start = end = -1;\n    } else {\n      throw new SyntaxError(`Unexpected character at index ${i}`);\n    }\n  }\n\n  if (start === -1 || end !== -1) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  const protocol = header.slice(start, i);\n\n  if (protocols.has(protocol)) {\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n  }\n\n  protocols.add(protocol);\n  return protocols;\n}\n\nmodule.exports = { parse };\n","'use strict';\n\nconst { isUtf8 } = require('buffer');\n\nconst { hasBlob } = require('./constants');\n\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */\nfunction isValidStatusCode(code) {\n  return (\n    (code >= 1000 &&\n      code <= 1014 &&\n      code !== 1004 &&\n      code !== 1005 &&\n      code !== 1006) ||\n    (code >= 3000 && code <= 4999)\n  );\n}\n\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\nfunction _isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n\n  while (i < len) {\n    if ((buf[i] & 0x80) === 0) {\n      // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {\n      // 110xxxxx 10xxxxxx\n      if (\n        i + 1 === len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i] & 0xfe) === 0xc0 // Overlong\n      ) {\n        return false;\n      }\n\n      i += 2;\n    } else if ((buf[i] & 0xf0) === 0xe0) {\n      // 1110xxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 2 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong\n        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      }\n\n      i += 3;\n    } else if ((buf[i] & 0xf8) === 0xf0) {\n      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 3 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i + 3] & 0xc0) !== 0x80 ||\n        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong\n        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||\n        buf[i] > 0xf4 // > U+10FFFF\n      ) {\n        return false;\n      }\n\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Determines whether a value is a `Blob`.\n *\n * @param {*} value The value to be tested\n * @return {Boolean} `true` if `value` is a `Blob`, else `false`\n * @private\n */\nfunction isBlob(value) {\n  return (\n    hasBlob &&\n    typeof value === 'object' &&\n    typeof value.arrayBuffer === 'function' &&\n    typeof value.type === 'string' &&\n    typeof value.stream === 'function' &&\n    (value[Symbol.toStringTag] === 'Blob' ||\n      value[Symbol.toStringTag] === 'File')\n  );\n}\n\nmodule.exports = {\n  isBlob,\n  isValidStatusCode,\n  isValidUTF8: _isValidUTF8,\n  tokenChars\n};\n\nif (isUtf8) {\n  module.exports.isValidUTF8 = function (buf) {\n    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\n  };\n} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {\n  try {\n    const isValidUTF8 = require('utf-8-validate');\n\n    module.exports.isValidUTF8 = function (buf) {\n      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}\n","/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex$\", \"caughtErrors\": \"none\" }] */\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst http = require('http');\nconst { Duplex } = require('stream');\nconst { createHash } = require('crypto');\n\nconst extension = require('./extension');\nconst PerMessageDeflate = require('./permessage-deflate');\nconst subprotocol = require('./subprotocol');\nconst WebSocket = require('./websocket');\nconst { GUID, kWebSocket } = require('./constants');\n\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\n\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n   *     automatically send a pong in response to a ping\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n\n    options = {\n      allowSynchronousEvents: true,\n      autoPong: true,\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null, // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket,\n      ...options\n    };\n\n    if (\n      (options.port == null && !options.server && !options.noServer) ||\n      (options.port != null && (options.server || options.noServer)) ||\n      (options.server && options.noServer)\n    ) {\n      throw new TypeError(\n        'One and only one of the \"port\", \"server\", or \"noServer\" options ' +\n          'must be specified'\n      );\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(\n        options.port,\n        options.host,\n        options.backlog,\n        callback\n      );\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, 'connection');\n\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) {\n      this.clients = new Set();\n      this._shouldEmitClose = false;\n    }\n\n    this.options = options;\n    this._state = RUNNING;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb) {\n        this.once('close', () => {\n          cb(new Error('The server is not running'));\n        });\n      }\n\n      process.nextTick(emitClose, this);\n      return;\n    }\n\n    if (cb) this.once('close', cb);\n\n    if (this._state === CLOSING) return;\n    this._state = CLOSING;\n\n    if (this.options.noServer || this.options.server) {\n      if (this._server) {\n        this._removeListeners();\n        this._removeListeners = this._server = null;\n      }\n\n      if (this.clients) {\n        if (!this.clients.size) {\n          process.nextTick(emitClose, this);\n        } else {\n          this._shouldEmitClose = true;\n        }\n      } else {\n        process.nextTick(emitClose, this);\n      }\n    } else {\n      const server = this._server;\n\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // The HTTP/S server was created internally. Close it, and rely on its\n      // `'close'` event.\n      //\n      server.close(() => {\n        emitClose(this);\n      });\n    }\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n\n      if (pathname !== this.options.path) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n\n    const key = req.headers['sec-websocket-key'];\n    const upgrade = req.headers.upgrade;\n    const version = +req.headers['sec-websocket-version'];\n\n    if (req.method !== 'GET') {\n      const message = 'Invalid HTTP method';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n      return;\n    }\n\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n      const message = 'Invalid Upgrade header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (key === undefined || !keyRegex.test(key)) {\n      const message = 'Missing or invalid Sec-WebSocket-Key header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (version !== 8 && version !== 13) {\n      const message = 'Missing or invalid Sec-WebSocket-Version header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (!this.shouldHandle(req)) {\n      abortHandshake(socket, 400);\n      return;\n    }\n\n    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];\n    let protocols = new Set();\n\n    if (secWebSocketProtocol !== undefined) {\n      try {\n        protocols = subprotocol.parse(secWebSocketProtocol);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Protocol header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];\n    const extensions = {};\n\n    if (\n      this.options.perMessageDeflate &&\n      secWebSocketExtensions !== undefined\n    ) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = extension.parse(secWebSocketExtensions);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        const message =\n          'Invalid or unacceptable Sec-WebSocket-Extensions header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin:\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(\n            extensions,\n            key,\n            protocols,\n            req,\n            socket,\n            head,\n            cb\n          );\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    if (socket[kWebSocket]) {\n      throw new Error(\n        'server.handleUpgrade() was called more than once with the same ' +\n          'socket, possibly due to a misconfiguration'\n      );\n    }\n\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${digest}`\n    ];\n\n    const ws = new this.options.WebSocket(null, undefined, this.options);\n\n    if (protocols.size) {\n      //\n      // Optionally call external protocol selection handler.\n      //\n      const protocol = this.options.handleProtocols\n        ? this.options.handleProtocols(protocols, req)\n        : protocols.values().next().value;\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n\n    ws.setSocket(socket, head, {\n      allowSynchronousEvents: this.options.allowSynchronousEvents,\n      maxPayload: this.options.maxPayload,\n      skipUTF8Validation: this.options.skipUTF8Validation\n    });\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => {\n        this.clients.delete(ws);\n\n        if (this._shouldEmitClose && !this.clients.size) {\n          process.nextTick(emitClose, this);\n        }\n      });\n    }\n\n    cb(ws, req);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit('close');\n}\n\n/**\n * Handle socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  //\n  // The socket is writable unless the user destroyed or ended it before calling\n  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user\n  // error. Handling this does not make much sense as the worst that can happen\n  // is that some of the data written by the user might be discarded due to the\n  // call to `socket.end()` below, which triggers an `'error'` event that in\n  // turn causes the socket to be destroyed.\n  //\n  message = message || http.STATUS_CODES[code];\n  headers = {\n    Connection: 'close',\n    'Content-Type': 'text/html',\n    'Content-Length': Buffer.byteLength(message),\n    ...headers\n  };\n\n  socket.once('finish', socket.destroy);\n\n  socket.end(\n    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\n      Object.keys(headers)\n        .map((h) => `${h}: ${headers[h]}`)\n        .join('\\r\\n') +\n      '\\r\\n\\r\\n' +\n      message\n  );\n}\n\n/**\n * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least\n * one listener for it, otherwise call `abortHandshake()`.\n *\n * @param {WebSocketServer} server The WebSocket server\n * @param {http.IncomingMessage} req The request object\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} message The HTTP response body\n * @private\n */\nfunction abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\n  if (server.listenerCount('wsClientError')) {\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n\n    server.emit('wsClientError', err, socket, req);\n  } else {\n    abortHandshake(socket, code, message);\n  }\n}\n","/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex|Readable$\", \"caughtErrors\": \"none\" }] */\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst https = require('https');\nconst http = require('http');\nconst net = require('net');\nconst tls = require('tls');\nconst { randomBytes, createHash } = require('crypto');\nconst { Duplex, Readable } = require('stream');\nconst { URL } = require('url');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst Receiver = require('./receiver');\nconst Sender = require('./sender');\nconst { isBlob } = require('./validation');\n\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = require('./constants');\nconst {\n  EventTarget: { addEventListener, removeEventListener }\n} = require('./event-target');\nconst { format, parse } = require('./extension');\nconst { toBuffer } = require('./buffer-util');\n\nconst closeTimeout = 30 * 1000;\nconst kAborted = Symbol('kAborted');\nconst protocolVersions = [8, 13];\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._errorEmitted = false;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = '';\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (protocols === undefined) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === 'object' && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._autoPong = options.autoPong;\n      this._isServer = true;\n    }\n  }\n\n  /**\n   * For historical reasons, the custom \"nodebuffer\" type is used by the default\n   * instead of \"blob\".\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get isPaused() {\n    return this._paused;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return null;\n  }\n\n  /**\n   * @type {String}\n   */\n  get protocol() {\n    return this._protocol;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get readyState() {\n    return this._readyState;\n  }\n\n  /**\n   * @type {String}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n  setSocket(socket, head, options) {\n    const receiver = new Receiver({\n      allowSynchronousEvents: options.allowSynchronousEvents,\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n\n    const sender = new Sender(socket, this._extensions, options.generateMask);\n\n    this._receiver = receiver;\n    this._sender = sender;\n    this._socket = socket;\n\n    receiver[kWebSocket] = this;\n    sender[kWebSocket] = this;\n    socket[kWebSocket] = this;\n\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n\n    sender.onerror = senderOnError;\n\n    //\n    // These methods may not be available if `socket` is just a `Duplex`.\n    //\n    if (socket.setTimeout) socket.setTimeout(0);\n    if (socket.setNoDelay) socket.setNoDelay();\n\n    if (head.length > 0) socket.unshift(head);\n\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n\n    this._readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      abortHandshake(this, this._req, msg);\n      return;\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (\n        this._closeFrameSent &&\n        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)\n      ) {\n        this._socket.end();\n      }\n\n      return;\n    }\n\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n\n      if (\n        this._closeFrameReceived ||\n        this._receiver._writableState.errorEmitted\n      ) {\n        this._socket.end();\n      }\n    });\n\n    setCloseTimer(this);\n  }\n\n  /**\n   * Pause the socket.\n   *\n   * @public\n   */\n  pause() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = true;\n    this._socket.pause();\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Resume the socket.\n   *\n   * @public\n   */\n  resume() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      abortHandshake(this, this._req, msg);\n      return;\n    }\n\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n[\n  'binaryType',\n  'bufferedAmount',\n  'extensions',\n  'isPaused',\n  'protocol',\n  'readyState',\n  'url'\n].forEach((property) => {\n  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) return listener[kListener];\n      }\n\n      return null;\n    },\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n\n      if (typeof handler !== 'function') return;\n\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any\n *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple\n *     times in the same tick\n * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n *     automatically send a pong in response to a ping\n * @param {Function} [options.finishRequest] A function which can be used to\n *     customize the headers of each http request before it is sent\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    allowSynchronousEvents: true,\n    autoPong: true,\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: 'GET',\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  websocket._autoPong = opts.autoPong;\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\n        `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n  }\n\n  if (parsedUrl.protocol === 'http:') {\n    parsedUrl.protocol = 'ws:';\n  } else if (parsedUrl.protocol === 'https:') {\n    parsedUrl.protocol = 'wss:';\n  }\n\n  websocket._url = parsedUrl.href;\n\n  const isSecure = parsedUrl.protocol === 'wss:';\n  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';\n  let invalidUrlMessage;\n\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {\n    invalidUrlMessage =\n      'The URL\\'s protocol must be one of \"ws:\", \"wss:\", ' +\n      '\"http:\", \"https\", or \"ws+unix:\"';\n  } else if (isIpcUrl && !parsedUrl.pathname) {\n    invalidUrlMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidUrlMessage = 'The URL contains a fragment identifier';\n  }\n\n  if (invalidUrlMessage) {\n    const err = new SyntaxError(invalidUrlMessage);\n\n    if (websocket._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket, err);\n      return;\n    }\n  }\n\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const request = isSecure ? https.request : http.request;\n  const protocolSet = new Set();\n  let perMessageDeflate;\n\n  opts.createConnection =\n    opts.createConnection || (isSecure ? tlsConnect : netConnect);\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[')\n    ? parsedUrl.hostname.slice(1, -1)\n    : parsedUrl.hostname;\n  opts.headers = {\n    ...opts.headers,\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket'\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (\n        typeof protocol !== 'string' ||\n        !subprotocolRegex.test(protocol) ||\n        protocolSet.has(protocol)\n      ) {\n        throw new SyntaxError(\n          'An invalid or duplicated subprotocol was specified'\n        );\n      }\n\n      protocolSet.add(protocol);\n    }\n\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isIpcUrl) {\n    const parts = opts.path.split(':');\n\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  let req;\n\n  if (opts.followRedirects) {\n    if (websocket._redirects === 0) {\n      websocket._originalIpc = isIpcUrl;\n      websocket._originalSecure = isSecure;\n      websocket._originalHostOrSocketPath = isIpcUrl\n        ? opts.socketPath\n        : parsedUrl.host;\n\n      const headers = options && options.headers;\n\n      //\n      // Shallow copy the user provided options so that headers can be changed\n      // without mutating the original object.\n      //\n      options = { ...options, headers: {} };\n\n      if (headers) {\n        for (const [key, value] of Object.entries(headers)) {\n          options.headers[key.toLowerCase()] = value;\n        }\n      }\n    } else if (websocket.listenerCount('redirect') === 0) {\n      const isSameHost = isIpcUrl\n        ? websocket._originalIpc\n          ? opts.socketPath === websocket._originalHostOrSocketPath\n          : false\n        : websocket._originalIpc\n          ? false\n          : parsedUrl.host === websocket._originalHostOrSocketPath;\n\n      if (!isSameHost || (websocket._originalSecure && !isSecure)) {\n        //\n        // Match curl 7.77.0 behavior and drop the following headers. These\n        // headers are also dropped when following a redirect to a subdomain.\n        //\n        delete opts.headers.authorization;\n        delete opts.headers.cookie;\n\n        if (!isSameHost) delete opts.headers.host;\n\n        opts.auth = undefined;\n      }\n    }\n\n    //\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n    // If the `Authorization` header is set, then there is nothing to do as it\n    // will take precedence.\n    //\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization =\n        'Basic ' + Buffer.from(opts.auth).toString('base64');\n    }\n\n    req = websocket._req = request(opts);\n\n    if (websocket._redirects) {\n      //\n      // Unlike what is done for the `'upgrade'` event, no early exit is\n      // triggered here if the user calls `websocket.close()` or\n      // `websocket.terminate()` from a listener of the `'redirect'` event. This\n      // is because the user can also call `request.destroy()` with an error\n      // before calling `websocket.close()` or `websocket.terminate()` and this\n      // would result in an error being emitted on the `request` object with no\n      // `'error'` event listeners attached.\n      //\n      websocket.emit('redirect', websocket.url, req);\n    }\n  } else {\n    req = websocket._req = request(opts);\n  }\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', (err) => {\n    if (req === null || req[kAborted]) return;\n\n    req = websocket._req = null;\n    emitErrorAndClose(websocket, err);\n  });\n\n  req.on('response', (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (\n      location &&\n      opts.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400\n    ) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n\n      let addr;\n\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket, err);\n        return;\n      }\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(\n        websocket,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the\n    // `'upgrade'` event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n\n    req = websocket._req = null;\n\n    const upgrade = res.headers.upgrade;\n\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n      abortHandshake(websocket, socket, 'Invalid Upgrade header');\n      return;\n    }\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    let protError;\n\n    if (serverProt !== undefined) {\n      if (!protocolSet.size) {\n        protError = 'Server sent a subprotocol but none was requested';\n      } else if (!protocolSet.has(serverProt)) {\n        protError = 'Server sent an invalid subprotocol';\n      }\n    } else if (protocolSet.size) {\n      protError = 'Server sent no subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket._protocol = serverProt;\n\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        const message =\n          'Server sent a Sec-WebSocket-Extensions header but no extension ' +\n          'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      let extensions;\n\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      const extensionNames = Object.keys(extensions);\n\n      if (\n        extensionNames.length !== 1 ||\n        extensionNames[0] !== PerMessageDeflate.extensionName\n      ) {\n        const message = 'Server indicated an extension that was not requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      websocket._extensions[PerMessageDeflate.extensionName] =\n        perMessageDeflate;\n    }\n\n    websocket.setSocket(socket, head, {\n      allowSynchronousEvents: opts.allowSynchronousEvents,\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n\n  if (opts.finishRequest) {\n    opts.finishRequest(req, websocket);\n  } else {\n    req.end();\n  }\n}\n\n/**\n * Emit the `'error'` and `'close'` events.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */\nfunction emitErrorAndClose(websocket, err) {\n  websocket._readyState = WebSocket.CLOSING;\n  //\n  // The following assignment is practically useless and is done only for\n  // consistency.\n  //\n  websocket._errorEmitted = true;\n  websocket.emit('error', err);\n  websocket.emitClose();\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream[kAborted] = true;\n    stream.abort();\n\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n\n    process.nextTick(emitErrorAndClose, websocket, err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = isBlob(data) ? data.size : toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\n    else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\n        `(${readyStates[websocket.readyState]})`\n    );\n    process.nextTick(cb, err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n\n  if (websocket._socket[kWebSocket] === undefined) return;\n\n  websocket._socket.removeListener('data', socketOnData);\n  process.nextTick(resume, websocket._socket);\n\n  if (code === 1005) websocket.close();\n  else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  const websocket = this[kWebSocket];\n\n  if (!websocket.isPaused) websocket._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData);\n\n    //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n    process.nextTick(resume, websocket._socket);\n\n    websocket.close(err[kStatusCode]);\n  }\n\n  if (!websocket._errorEmitted) {\n    websocket._errorEmitted = true;\n    websocket.emit('error', err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket].emit('message', data, isBinary);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\nfunction resume(stream) {\n  stream.resume();\n}\n\n/**\n * The `Sender` error event handler.\n *\n * @param {Error} The error\n * @private\n */\nfunction senderOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket.readyState === WebSocket.CLOSED) return;\n  if (websocket.readyState === WebSocket.OPEN) {\n    websocket._readyState = WebSocket.CLOSING;\n    setCloseTimer(websocket);\n  }\n\n  //\n  // `socket.end()` is used instead of `socket.destroy()` to allow the other\n  // peer to finish sending queued data. There is no need to set a timer here\n  // because `CLOSING` means that it is already set or not needed.\n  //\n  this._socket.end();\n\n  if (!websocket._errorEmitted) {\n    websocket._errorEmitted = true;\n    websocket.emit('error', err);\n  }\n}\n\n/**\n * Set a timer to destroy the underlying raw socket of a WebSocket.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @private\n */\nfunction setCloseTimer(websocket) {\n  websocket._closeTimer = setTimeout(\n    websocket._socket.destroy.bind(websocket._socket),\n    closeTimeout\n  );\n}\n\n/**\n * The listener of the socket `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n\n  websocket._readyState = WebSocket.CLOSING;\n\n  let chunk;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n  if (\n    !this._readableState.endEmitted &&\n    !websocket._closeFrameReceived &&\n    !websocket._receiver._writableState.errorEmitted &&\n    (chunk = websocket._socket.read()) !== null\n  ) {\n    websocket._receiver.write(chunk);\n  }\n\n  websocket._receiver.end();\n\n  this[kWebSocket] = undefined;\n\n  clearTimeout(websocket._closeTimer);\n\n  if (\n    websocket._receiver._writableState.finished ||\n    websocket._receiver._writableState.errorEmitted\n  ) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the socket `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the socket `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n\n  websocket._readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the socket `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}\n","import createWebSocketStream from './lib/stream.js';\nimport Receiver from './lib/receiver.js';\nimport Sender from './lib/sender.js';\nimport WebSocket from './lib/websocket.js';\nimport WebSocketServer from './lib/websocket-server.js';\n\nexport { createWebSocketStream, Receiver, Sender, WebSocket, WebSocketServer };\nexport default WebSocket;\n"],"names":["EMPTY_BUFFER","__webpack_require__","FastBuffer","Buffer","Symbol","species","_mask","source","mask","output","offset","length","i","_unmask","buffer","module","exports","concat","list","totalLength","target","allocUnsafe","buf","set","byteOffset","toArrayBuffer","byteLength","slice","toBuffer","data","readOnly","isBuffer","ArrayBuffer","isView","from","unmask","process","env","WS_NO_BUFFER_UTIL","bufferUtil","e","BINARY_TYPES","hasBlob","Blob","push","alloc","GUID","kForOnEventAttribute","kListener","kStatusCode","kWebSocket","NOOP","kCode","kData","kError","kMessage","kReason","kTarget","kType","kWasClean","Event","constructor","type","Object","defineProperty","prototype","enumerable","CloseEvent","options","undefined","code","reason","wasClean","ErrorEvent","error","message","MessageEvent","callListener","listener","thisArg","event","handleEvent","call","EventTarget","addEventListener","handler","wrapper","listeners","isBinary","toString","_closeFrameReceived","_closeFrameSent","once","on","removeEventListener","removeListener","tokenChars","dest","name","elem","format","extensions","keys","map","configurations","extension","Array","isArray","params","values","k","v","join","parse","header","extensionName","paramName","offers","create","mustUnescape","isEscaping","inQuotes","start","end","charCodeAt","value","replace","token","kDone","kRun","Limiter","concurrency","pending","Infinity","jobs","add","job","shift","zlibLimiter","zlib","TRAILER","kPerMessageDeflate","kTotalLength","kCallback","kBuffers","PerMessageDeflate","isServer","maxPayload","_maxPayload","_options","_threshold","threshold","_isServer","_deflate","_inflate","concurrencyLimit","offer","serverNoContextTakeover","server_no_context_takeover","clientNoContextTakeover","client_no_context_takeover","serverMaxWindowBits","server_max_window_bits","clientMaxWindowBits","client_max_window_bits","accept","normalizeParams","acceptAsServer","acceptAsClient","cleanup","close","callback","opts","accepted","find","response","forEach","key","num","Number","isInteger","decompress","fin","_decompress","err","result","done","compress","_compress","endpoint","windowBits","Z_DEFAULT_WINDOWBITS","createInflateRaw","zlibInflateOptions","inflateOnError","inflateOnData","write","flush","_readableState","endEmitted","reset","createDeflateRaw","zlibDeflateOptions","deflateOnData","Z_SYNC_FLUSH","chunk","Writable","isValidStatusCode","isValidUTF8","Receiver","_allowSynchronousEvents","allowSynchronousEvents","_binaryType","binaryType","_extensions","_skipUTF8Validation","skipUTF8Validation","_bufferedBytes","_buffers","_compressed","_payloadLength","_fragmented","_masked","_fin","_opcode","_totalPayloadLength","_messageLength","_fragments","_errored","_loop","_state","_write","encoding","cb","startLoop","consume","n","dst","Uint8Array","getInfo","getPayloadLength16","getPayloadLength64","getMask","getData","createError","RangeError","compressed","haveLength","readUInt16BE","readUInt32BE","Math","controlMessage","dataMessage","perMessageDeflate","messageLength","fragments","emit","setImmediate","Error","ErrorCtor","prefix","statusCode","errorCode","captureStackTrace","randomPool","Duplex","require","randomFillSync","isBlob","applyMask","kByteLength","maskBuffer","randomPoolPointer","Sender","socket","generateMask","_generateMask","_maskBuffer","_socket","_firstFragment","_queue","onerror","frame","dataLength","merge","skipMasking","RANDOM_POOL_SIZE","payloadLength","opcode","rsv1","writeUInt16BE","writeUIntBE","enqueue","dispatch","sendFrame","ping","size","getBlobData","pong","send","binary","blob","arrayBuffer","then","destroyed","nextTick","callCallbacks","dequeue","catch","onError","_","Reflect","apply","cork","uncork","sender","emitClose","stream","duplexOnEnd","_writableState","finished","destroy","duplexOnError","listenerCount","ws","terminateOnDestroy","duplex","autoDestroy","objectMode","writableObjectMode","msg","pause","_destroy","readyState","CLOSED","called","terminate","_final","CONNECTING","_read","isPaused","resume","protocols","Set","protocol","has","isUtf8","_isValidUTF8","len","toStringTag","WS_NO_UTF_8_VALIDATE","EventEmitter","http","createHash","subprotocol","WebSocket","keyRegex","WebSocketServer","autoPong","handleProtocols","clientTracking","verifyClient","noServer","backlog","server","host","path","port","_server","createServer","req","res","body","STATUS_CODES","writeHead","listen","emitConnection","bind","_removeListeners","addListeners","listening","upgrade","head","handleUpgrade","clients","_shouldEmitClose","address","shouldHandle","index","url","indexOf","pathname","socketOnError","headers","version","method","abortHandshakeOrEmitwsClientError","toLowerCase","test","abortHandshake","secWebSocketProtocol","secWebSocketExtensions","info","origin","secure","authorized","encrypted","verified","completeUpgrade","readable","writable","digest","update","next","_protocol","setSocket","delete","Connection","h","https","net","tls","randomBytes","Readable","URL","kAborted","protocolVersions","readyStates","subprotocolRegex","_closeCode","_closeMessage","_closeTimer","_errorEmitted","_paused","_readyState","_receiver","_sender","_bufferedAmount","_redirects","initAsClient","websocket","parsedUrl","invalidUrlMessage","protocolVersion","followRedirects","maxRedirects","socketPath","hostname","timeout","_autoPong","includes","_url","href","isSecure","isIpcUrl","hash","emitErrorAndClose","defaultPort","request","protocolSet","createConnection","tlsConnect","netConnect","startsWith","Upgrade","search","handshakeTimeout","Origin","username","password","auth","parts","split","_originalIpc","_originalSecure","_originalHostOrSocketPath","entries","isSameHost","authorization","cookie","_req","location","addr","abort","protError","serverProt","extensionNames","finishRequest","bufferedAmount","onclose","onopen","onmessage","receiver","receiverOnConclude","receiverOnDrain","receiverOnError","receiverOnMessage","receiverOnPing","receiverOnPong","senderOnError","setTimeout","setNoDelay","unshift","socketOnClose","socketOnData","socketOnEnd","OPEN","removeAllListeners","CLOSING","errorEmitted","setCloseTimer","sendAfterClose","needDrain","connect","servername","isIP","setHeader","receiverOnFinish","read","clearTimeout","property","get","__WEBPACK_DEFAULT_EXPORT__","_lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__"],"sourceRoot":""}