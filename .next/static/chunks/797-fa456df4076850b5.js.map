{"version":3,"file":"static/chunks/797-fa456df4076850b5.js","mappings":"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","sources":["webpack://_N_E/./node_modules/.pnpm/@tanstack+query-core@5.62.2/node_modules/@tanstack/query-core/build/modern/focusManager.js","webpack://_N_E/./node_modules/.pnpm/@tanstack+query-core@5.62.2/node_modules/@tanstack/query-core/build/modern/notifyManager.js","webpack://_N_E/./node_modules/.pnpm/@tanstack+query-core@5.62.2/node_modules/@tanstack/query-core/build/modern/onlineManager.js","webpack://_N_E/./node_modules/.pnpm/@tanstack+query-core@5.62.2/node_modules/@tanstack/query-core/build/modern/query.js","webpack://_N_E/./node_modules/.pnpm/@tanstack+query-core@5.62.2/node_modules/@tanstack/query-core/build/modern/queryObserver.js","webpack://_N_E/./node_modules/.pnpm/@tanstack+query-core@5.62.2/node_modules/@tanstack/query-core/build/modern/removable.js","webpack://_N_E/./node_modules/.pnpm/@tanstack+query-core@5.62.2/node_modules/@tanstack/query-core/build/modern/retryer.js","webpack://_N_E/./node_modules/.pnpm/@tanstack+query-core@5.62.2/node_modules/@tanstack/query-core/build/modern/subscribable.js","webpack://_N_E/./node_modules/.pnpm/@tanstack+query-core@5.62.2/node_modules/@tanstack/query-core/build/modern/thenable.js","webpack://_N_E/./node_modules/.pnpm/@tanstack+query-core@5.62.2/node_modules/@tanstack/query-core/build/modern/utils.js","webpack://_N_E/../../src/QueryClientProvider.tsx","webpack://_N_E/../../src/QueryErrorResetBoundary.tsx","webpack://_N_E/../../src/errorBoundaryUtils.ts","webpack://_N_E/../../src/isRestoring.ts","webpack://_N_E/./node_modules/.pnpm/@tanstack+react-query@5.62.2_react@18.3.1/node_modules/@tanstack/react-query/build/modern/suspense.js","webpack://_N_E/../../src/useBaseQuery.ts","webpack://_N_E/../../src/useQuery.ts","webpack://_N_E/./node_modules/.pnpm/@tanstack+react-query@5.62.2_react@18.3.1/node_modules/@tanstack/react-query/build/modern/utils.js"],"sourcesContent":["// src/focusManager.ts\nimport { Subscribable } from \"./subscribable.js\";\nimport { isServer } from \"./utils.js\";\nvar FocusManager = class extends Subscribable {\n  #focused;\n  #cleanup;\n  #setup;\n  constructor() {\n    super();\n    this.#setup = (onFocus) => {\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus();\n        window.addEventListener(\"visibilitychange\", listener, false);\n        return () => {\n          window.removeEventListener(\"visibilitychange\", listener);\n        };\n      }\n      return;\n    };\n  }\n  onSubscribe() {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.();\n      this.#cleanup = void 0;\n    }\n  }\n  setEventListener(setup) {\n    this.#setup = setup;\n    this.#cleanup?.();\n    this.#cleanup = setup((focused) => {\n      if (typeof focused === \"boolean\") {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n  setFocused(focused) {\n    const changed = this.#focused !== focused;\n    if (changed) {\n      this.#focused = focused;\n      this.onFocus();\n    }\n  }\n  onFocus() {\n    const isFocused = this.isFocused();\n    this.listeners.forEach((listener) => {\n      listener(isFocused);\n    });\n  }\n  isFocused() {\n    if (typeof this.#focused === \"boolean\") {\n      return this.#focused;\n    }\n    return globalThis.document?.visibilityState !== \"hidden\";\n  }\n};\nvar focusManager = new FocusManager();\nexport {\n  FocusManager,\n  focusManager\n};\n//# sourceMappingURL=focusManager.js.map","// src/notifyManager.ts\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n  let notifyFn = (callback) => {\n    callback();\n  };\n  let batchNotifyFn = (callback) => {\n    callback();\n  };\n  let scheduleFn = (cb) => setTimeout(cb, 0);\n  const schedule = (callback) => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleFn(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n    if (originalQueue.length) {\n      scheduleFn(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  return {\n    batch: (callback) => {\n      let result;\n      transactions++;\n      try {\n        result = callback();\n      } finally {\n        transactions--;\n        if (!transactions) {\n          flush();\n        }\n      }\n      return result;\n    },\n    /**\n     * All calls to the wrapped function will be batched.\n     */\n    batchCalls: (callback) => {\n      return (...args) => {\n        schedule(() => {\n          callback(...args);\n        });\n      };\n    },\n    schedule,\n    /**\n     * Use this method to set a custom notify function.\n     * This can be used to for example wrap notifications with `React.act` while running tests.\n     */\n    setNotifyFunction: (fn) => {\n      notifyFn = fn;\n    },\n    /**\n     * Use this method to set a custom function to batch notifications together into a single tick.\n     * By default React Query will use the batch function provided by ReactDOM or React Native.\n     */\n    setBatchNotifyFunction: (fn) => {\n      batchNotifyFn = fn;\n    },\n    setScheduler: (fn) => {\n      scheduleFn = fn;\n    }\n  };\n}\nvar notifyManager = createNotifyManager();\nexport {\n  createNotifyManager,\n  notifyManager\n};\n//# sourceMappingURL=notifyManager.js.map","// src/onlineManager.ts\nimport { Subscribable } from \"./subscribable.js\";\nimport { isServer } from \"./utils.js\";\nvar OnlineManager = class extends Subscribable {\n  #online = true;\n  #cleanup;\n  #setup;\n  constructor() {\n    super();\n    this.#setup = (onOnline) => {\n      if (!isServer && window.addEventListener) {\n        const onlineListener = () => onOnline(true);\n        const offlineListener = () => onOnline(false);\n        window.addEventListener(\"online\", onlineListener, false);\n        window.addEventListener(\"offline\", offlineListener, false);\n        return () => {\n          window.removeEventListener(\"online\", onlineListener);\n          window.removeEventListener(\"offline\", offlineListener);\n        };\n      }\n      return;\n    };\n  }\n  onSubscribe() {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.();\n      this.#cleanup = void 0;\n    }\n  }\n  setEventListener(setup) {\n    this.#setup = setup;\n    this.#cleanup?.();\n    this.#cleanup = setup(this.setOnline.bind(this));\n  }\n  setOnline(online) {\n    const changed = this.#online !== online;\n    if (changed) {\n      this.#online = online;\n      this.listeners.forEach((listener) => {\n        listener(online);\n      });\n    }\n  }\n  isOnline() {\n    return this.#online;\n  }\n};\nvar onlineManager = new OnlineManager();\nexport {\n  OnlineManager,\n  onlineManager\n};\n//# sourceMappingURL=onlineManager.js.map","// src/query.ts\nimport {\n  ensureQueryFn,\n  noop,\n  replaceData,\n  resolveEnabled,\n  skipToken,\n  timeUntilStale\n} from \"./utils.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { canFetch, createRetryer, isCancelledError } from \"./retryer.js\";\nimport { Removable } from \"./removable.js\";\nvar Query = class extends Removable {\n  #initialState;\n  #revertState;\n  #cache;\n  #retryer;\n  #defaultOptions;\n  #abortSignalConsumed;\n  constructor(config) {\n    super();\n    this.#abortSignalConsumed = false;\n    this.#defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.#cache = config.cache;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.#initialState = getDefaultState(this.options);\n    this.state = config.state ?? this.#initialState;\n    this.scheduleGc();\n  }\n  get meta() {\n    return this.options.meta;\n  }\n  get promise() {\n    return this.#retryer?.promise;\n  }\n  setOptions(options) {\n    this.options = { ...this.#defaultOptions, ...options };\n    this.updateGcTime(this.options.gcTime);\n  }\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === \"idle\") {\n      this.#cache.remove(this);\n    }\n  }\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options);\n    this.#dispatch({\n      data,\n      type: \"success\",\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual\n    });\n    return data;\n  }\n  setState(state, setStateOptions) {\n    this.#dispatch({ type: \"setState\", state, setStateOptions });\n  }\n  cancel(options) {\n    const promise = this.#retryer?.promise;\n    this.#retryer?.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n  destroy() {\n    super.destroy();\n    this.cancel({ silent: true });\n  }\n  reset() {\n    this.destroy();\n    this.setState(this.#initialState);\n  }\n  isActive() {\n    return this.observers.some(\n      (observer) => resolveEnabled(observer.options.enabled, this) !== false\n    );\n  }\n  isDisabled() {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive();\n    }\n    return this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;\n  }\n  isStale() {\n    if (this.state.isInvalidated) {\n      return true;\n    }\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale\n      );\n    }\n    return this.state.data === void 0;\n  }\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || this.state.data === void 0 || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n  onFocus() {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());\n    observer?.refetch({ cancelRefetch: false });\n    this.#retryer?.continue();\n  }\n  onOnline() {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect());\n    observer?.refetch({ cancelRefetch: false });\n    this.#retryer?.continue();\n  }\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer);\n      this.clearGcTimeout();\n      this.#cache.notify({ type: \"observerAdded\", query: this, observer });\n    }\n  }\n  removeObserver(observer) {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer);\n      if (!this.observers.length) {\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true });\n          } else {\n            this.#retryer.cancelRetry();\n          }\n        }\n        this.scheduleGc();\n      }\n      this.#cache.notify({ type: \"observerRemoved\", query: this, observer });\n    }\n  }\n  getObserversCount() {\n    return this.observers.length;\n  }\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: \"invalidate\" });\n    }\n  }\n  fetch(options, fetchOptions) {\n    if (this.state.fetchStatus !== \"idle\") {\n      if (this.state.data !== void 0 && fetchOptions?.cancelRefetch) {\n        this.cancel({ silent: true });\n      } else if (this.#retryer) {\n        this.#retryer.continueRetry();\n        return this.#retryer.promise;\n      }\n    }\n    if (options) {\n      this.setOptions(options);\n    }\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn);\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`\n        );\n      }\n    }\n    const abortController = new AbortController();\n    const addSignalProperty = (object) => {\n      Object.defineProperty(object, \"signal\", {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true;\n          return abortController.signal;\n        }\n      });\n    };\n    const fetchFn = () => {\n      const queryFn = ensureQueryFn(this.options, fetchOptions);\n      const queryFnContext = {\n        queryKey: this.queryKey,\n        meta: this.meta\n      };\n      addSignalProperty(queryFnContext);\n      this.#abortSignalConsumed = false;\n      if (this.options.persister) {\n        return this.options.persister(\n          queryFn,\n          queryFnContext,\n          this\n        );\n      }\n      return queryFn(queryFnContext);\n    };\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn\n    };\n    addSignalProperty(context);\n    this.options.behavior?.onFetch(\n      context,\n      this\n    );\n    this.#revertState = this.state;\n    if (this.state.fetchStatus === \"idle\" || this.state.fetchMeta !== context.fetchOptions?.meta) {\n      this.#dispatch({ type: \"fetch\", meta: context.fetchOptions?.meta });\n    }\n    const onError = (error) => {\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: \"error\",\n          error\n        });\n      }\n      if (!isCancelledError(error)) {\n        this.#cache.config.onError?.(\n          error,\n          this\n        );\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error,\n          this\n        );\n      }\n      this.scheduleGc();\n    };\n    this.#retryer = createRetryer({\n      initialPromise: fetchOptions?.initialPromise,\n      fn: context.fetchFn,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (data === void 0) {\n          if (process.env.NODE_ENV !== \"production\") {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`\n            );\n          }\n          onError(new Error(`${this.queryHash} data is undefined`));\n          return;\n        }\n        try {\n          this.setData(data);\n        } catch (error) {\n          onError(error);\n          return;\n        }\n        this.#cache.config.onSuccess?.(data, this);\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error,\n          this\n        );\n        this.scheduleGc();\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: \"failed\", failureCount, error });\n      },\n      onPause: () => {\n        this.#dispatch({ type: \"pause\" });\n      },\n      onContinue: () => {\n        this.#dispatch({ type: \"continue\" });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true\n    });\n    return this.#retryer.start();\n  }\n  #dispatch(action) {\n    const reducer = (state) => {\n      switch (action.type) {\n        case \"failed\":\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error\n          };\n        case \"pause\":\n          return {\n            ...state,\n            fetchStatus: \"paused\"\n          };\n        case \"continue\":\n          return {\n            ...state,\n            fetchStatus: \"fetching\"\n          };\n        case \"fetch\":\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null\n          };\n        case \"success\":\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: \"success\",\n            ...!action.manual && {\n              fetchStatus: \"idle\",\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            }\n          };\n        case \"error\":\n          const error = action.error;\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: \"idle\" };\n          }\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: \"idle\",\n            status: \"error\"\n          };\n        case \"invalidate\":\n          return {\n            ...state,\n            isInvalidated: true\n          };\n        case \"setState\":\n          return {\n            ...state,\n            ...action.state\n          };\n      }\n    };\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate();\n      });\n      this.#cache.notify({ query: this, type: \"updated\", action });\n    });\n  }\n};\nfunction fetchState(data, options) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? \"fetching\" : \"paused\",\n    ...data === void 0 && {\n      error: null,\n      status: \"pending\"\n    }\n  };\n}\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === \"function\" ? options.initialData() : options.initialData;\n  const hasData = data !== void 0;\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === \"function\" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? \"success\" : \"pending\",\n    fetchStatus: \"idle\"\n  };\n}\nexport {\n  Query,\n  fetchState\n};\n//# sourceMappingURL=query.js.map","// src/queryObserver.ts\nimport { focusManager } from \"./focusManager.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { fetchState } from \"./query.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { pendingThenable } from \"./thenable.js\";\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  timeUntilStale\n} from \"./utils.js\";\nvar QueryObserver = class extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.options = options;\n    this.#client = client;\n    this.#selectError = null;\n    this.#currentThenable = pendingThenable();\n    if (!this.options.experimental_prefetchInRender) {\n      this.#currentThenable.reject(\n        new Error(\"experimental_prefetchInRender feature flag is not enabled\")\n      );\n    }\n    this.bindMethods();\n    this.setOptions(options);\n  }\n  #client;\n  #currentQuery = void 0;\n  #currentQueryInitialState = void 0;\n  #currentResult = void 0;\n  #currentResultState;\n  #currentResultOptions;\n  #currentThenable;\n  #selectError;\n  #selectFn;\n  #selectResult;\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData;\n  #staleTimeoutId;\n  #refetchIntervalId;\n  #currentRefetchInterval;\n  #trackedProps = /* @__PURE__ */ new Set();\n  bindMethods() {\n    this.refetch = this.refetch.bind(this);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this);\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch();\n      } else {\n        this.updateResult();\n      }\n      this.#updateTimers();\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect\n    );\n  }\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus\n    );\n  }\n  destroy() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.#clearStaleTimeout();\n    this.#clearRefetchInterval();\n    this.#currentQuery.removeObserver(this);\n  }\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.#currentQuery;\n    this.options = this.#client.defaultQueryOptions(options);\n    if (this.options.enabled !== void 0 && typeof this.options.enabled !== \"boolean\" && typeof this.options.enabled !== \"function\" && typeof resolveEnabled(this.options.enabled, this.#currentQuery) !== \"boolean\") {\n      throw new Error(\n        \"Expected enabled to be a boolean or a callback that returns a boolean\"\n      );\n    }\n    this.#updateQuery();\n    this.#currentQuery.setOptions(this.options);\n    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {\n      this.#client.getQueryCache().notify({\n        type: \"observerOptionsUpdated\",\n        query: this.#currentQuery,\n        observer: this\n      });\n    }\n    const mounted = this.hasListeners();\n    if (mounted && shouldFetchOptionally(\n      this.#currentQuery,\n      prevQuery,\n      this.options,\n      prevOptions\n    )) {\n      this.#executeFetch();\n    }\n    this.updateResult(notifyOptions);\n    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || resolveStaleTime(this.options.staleTime, this.#currentQuery) !== resolveStaleTime(prevOptions.staleTime, this.#currentQuery))) {\n      this.#updateStaleTimeout();\n    }\n    const nextRefetchInterval = this.#computeRefetchInterval();\n    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || nextRefetchInterval !== this.#currentRefetchInterval)) {\n      this.#updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n  getOptimisticResult(options) {\n    const query = this.#client.getQueryCache().build(this.#client, options);\n    const result = this.createResult(query, options);\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      this.#currentResult = result;\n      this.#currentResultOptions = this.options;\n      this.#currentResultState = this.#currentQuery.state;\n    }\n    return result;\n  }\n  getCurrentResult() {\n    return this.#currentResult;\n  }\n  trackResult(result, onPropTracked) {\n    const trackedResult = {};\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackProp(key);\n          onPropTracked?.(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n  trackProp(key) {\n    this.#trackedProps.add(key);\n  }\n  getCurrentQuery() {\n    return this.#currentQuery;\n  }\n  refetch({ ...options } = {}) {\n    return this.fetch({\n      ...options\n    });\n  }\n  fetchOptimistic(options) {\n    const defaultedOptions = this.#client.defaultQueryOptions(options);\n    const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n  fetch(fetchOptions) {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true\n    }).then(() => {\n      this.updateResult();\n      return this.#currentResult;\n    });\n  }\n  #executeFetch(fetchOptions) {\n    this.#updateQuery();\n    let promise = this.#currentQuery.fetch(\n      this.options,\n      fetchOptions\n    );\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop);\n    }\n    return promise;\n  }\n  #updateStaleTimeout() {\n    this.#clearStaleTimeout();\n    const staleTime = resolveStaleTime(\n      this.options.staleTime,\n      this.#currentQuery\n    );\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {\n      return;\n    }\n    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime);\n    const timeout = time + 1;\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n  #computeRefetchInterval() {\n    return (typeof this.options.refetchInterval === \"function\" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;\n  }\n  #updateRefetchInterval(nextInterval) {\n    this.#clearRefetchInterval();\n    this.#currentRefetchInterval = nextInterval;\n    if (isServer || resolveEnabled(this.options.enabled, this.#currentQuery) === false || !isValidTimeout(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {\n      return;\n    }\n    this.#refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.#executeFetch();\n      }\n    }, this.#currentRefetchInterval);\n  }\n  #updateTimers() {\n    this.#updateStaleTimeout();\n    this.#updateRefetchInterval(this.#computeRefetchInterval());\n  }\n  #clearStaleTimeout() {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId);\n      this.#staleTimeoutId = void 0;\n    }\n  }\n  #clearRefetchInterval() {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId);\n      this.#refetchIntervalId = void 0;\n    }\n  }\n  createResult(query, options) {\n    const prevQuery = this.#currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.#currentResult;\n    const prevResultState = this.#currentResultState;\n    const prevResultOptions = this.#currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;\n    const { state } = query;\n    let newState = { ...state };\n    let isPlaceholderData = false;\n    let data;\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...fetchState(state.data, query.options)\n        };\n      }\n      if (options._optimisticResults === \"isRestoring\") {\n        newState.fetchStatus = \"idle\";\n      }\n    }\n    let { error, errorUpdatedAt, status } = newState;\n    if (options.select && newState.data !== void 0) {\n      if (prevResult && newState.data === prevResultState?.data && options.select === this.#selectFn) {\n        data = this.#selectResult;\n      } else {\n        try {\n          this.#selectFn = options.select;\n          data = options.select(newState.data);\n          data = replaceData(prevResult?.data, data, options);\n          this.#selectResult = data;\n          this.#selectError = null;\n        } catch (selectError) {\n          this.#selectError = selectError;\n        }\n      }\n    } else {\n      data = newState.data;\n    }\n    if (options.placeholderData !== void 0 && data === void 0 && status === \"pending\") {\n      let placeholderData;\n      if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === \"function\" ? options.placeholderData(\n          this.#lastQueryWithDefinedData?.state.data,\n          this.#lastQueryWithDefinedData\n        ) : options.placeholderData;\n        if (options.select && placeholderData !== void 0) {\n          try {\n            placeholderData = options.select(placeholderData);\n            this.#selectError = null;\n          } catch (selectError) {\n            this.#selectError = selectError;\n          }\n        }\n      }\n      if (placeholderData !== void 0) {\n        status = \"success\";\n        data = replaceData(\n          prevResult?.data,\n          placeholderData,\n          options\n        );\n        isPlaceholderData = true;\n      }\n    }\n    if (this.#selectError) {\n      error = this.#selectError;\n      data = this.#selectResult;\n      errorUpdatedAt = Date.now();\n      status = \"error\";\n    }\n    const isFetching = newState.fetchStatus === \"fetching\";\n    const isPending = status === \"pending\";\n    const isError = status === \"error\";\n    const isLoading = isPending && isFetching;\n    const hasData = data !== void 0;\n    const result = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === \"success\",\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === \"paused\",\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      promise: this.#currentThenable\n    };\n    const nextResult = result;\n    if (this.options.experimental_prefetchInRender) {\n      const finalizeThenableIfPossible = (thenable) => {\n        if (nextResult.status === \"error\") {\n          thenable.reject(nextResult.error);\n        } else if (nextResult.data !== void 0) {\n          thenable.resolve(nextResult.data);\n        }\n      };\n      const recreateThenable = () => {\n        const pending = this.#currentThenable = nextResult.promise = pendingThenable();\n        finalizeThenableIfPossible(pending);\n      };\n      const prevThenable = this.#currentThenable;\n      switch (prevThenable.status) {\n        case \"pending\":\n          if (query.queryHash === prevQuery.queryHash) {\n            finalizeThenableIfPossible(prevThenable);\n          }\n          break;\n        case \"fulfilled\":\n          if (nextResult.status === \"error\" || nextResult.data !== prevThenable.value) {\n            recreateThenable();\n          }\n          break;\n        case \"rejected\":\n          if (nextResult.status !== \"error\" || nextResult.error !== prevThenable.reason) {\n            recreateThenable();\n          }\n          break;\n      }\n    }\n    return nextResult;\n  }\n  updateResult(notifyOptions) {\n    const prevResult = this.#currentResult;\n    const nextResult = this.createResult(this.#currentQuery, this.options);\n    this.#currentResultState = this.#currentQuery.state;\n    this.#currentResultOptions = this.options;\n    if (this.#currentResultState.data !== void 0) {\n      this.#lastQueryWithDefinedData = this.#currentQuery;\n    }\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n    this.#currentResult = nextResult;\n    const defaultNotifyOptions = {};\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n      const { notifyOnChangeProps } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === \"function\" ? notifyOnChangeProps() : notifyOnChangeProps;\n      if (notifyOnChangePropsValue === \"all\" || !notifyOnChangePropsValue && !this.#trackedProps.size) {\n        return true;\n      }\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps\n      );\n      if (this.options.throwOnError) {\n        includedProps.add(\"error\");\n      }\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key;\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n    this.#notify({ ...defaultNotifyOptions, ...notifyOptions });\n  }\n  #updateQuery() {\n    const query = this.#client.getQueryCache().build(this.#client, this.options);\n    if (query === this.#currentQuery) {\n      return;\n    }\n    const prevQuery = this.#currentQuery;\n    this.#currentQuery = query;\n    this.#currentQueryInitialState = query.state;\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n  onQueryUpdate() {\n    this.updateResult();\n    if (this.hasListeners()) {\n      this.#updateTimers();\n    }\n  }\n  #notify(notifyOptions) {\n    notifyManager.batch(() => {\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult);\n        });\n      }\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: \"observerResultsUpdated\"\n      });\n    });\n  }\n};\nfunction shouldLoadOnMount(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === \"error\" && options.retryOnMount === false);\n}\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\nfunction shouldFetchOn(query, options, field) {\n  if (resolveEnabled(options.enabled, query) !== false) {\n    const value = typeof field === \"function\" ? field(query) : field;\n    return value === \"always\" || value !== false && isStale(query, options);\n  }\n  return false;\n}\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== \"error\") && isStale(query, options);\n}\nfunction isStale(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));\n}\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult) {\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  }\n  return false;\n}\nexport {\n  QueryObserver\n};\n//# sourceMappingURL=queryObserver.js.map","// src/removable.ts\nimport { isServer, isValidTimeout } from \"./utils.js\";\nvar Removable = class {\n  #gcTimeout;\n  destroy() {\n    this.clearGcTimeout();\n  }\n  scheduleGc() {\n    this.clearGcTimeout();\n    if (isValidTimeout(this.gcTime)) {\n      this.#gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.gcTime);\n    }\n  }\n  updateGcTime(newGcTime) {\n    this.gcTime = Math.max(\n      this.gcTime || 0,\n      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)\n    );\n  }\n  clearGcTimeout() {\n    if (this.#gcTimeout) {\n      clearTimeout(this.#gcTimeout);\n      this.#gcTimeout = void 0;\n    }\n  }\n};\nexport {\n  Removable\n};\n//# sourceMappingURL=removable.js.map","// src/retryer.ts\nimport { focusManager } from \"./focusManager.js\";\nimport { onlineManager } from \"./onlineManager.js\";\nimport { pendingThenable } from \"./thenable.js\";\nimport { isServer, sleep } from \"./utils.js\";\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1e3 * 2 ** failureCount, 3e4);\n}\nfunction canFetch(networkMode) {\n  return (networkMode ?? \"online\") === \"online\" ? onlineManager.isOnline() : true;\n}\nvar CancelledError = class extends Error {\n  constructor(options) {\n    super(\"CancelledError\");\n    this.revert = options?.revert;\n    this.silent = options?.silent;\n  }\n};\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  const thenable = pendingThenable();\n  const cancel = (cancelOptions) => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort?.();\n    }\n  };\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n  const canContinue = () => focusManager.isFocused() && (config.networkMode === \"always\" || onlineManager.isOnline()) && config.canRun();\n  const canStart = () => canFetch(config.networkMode) && config.canRun();\n  const resolve = (value) => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess?.(value);\n      continueFn?.();\n      thenable.resolve(value);\n    }\n  };\n  const reject = (value) => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError?.(value);\n      continueFn?.();\n      thenable.reject(value);\n    }\n  };\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        if (isResolved || canContinue()) {\n          continueResolve(value);\n        }\n      };\n      config.onPause?.();\n    }).then(() => {\n      continueFn = void 0;\n      if (!isResolved) {\n        config.onContinue?.();\n      }\n    });\n  };\n  const run = () => {\n    if (isResolved) {\n      return;\n    }\n    let promiseOrValue;\n    const initialPromise = failureCount === 0 ? config.initialPromise : void 0;\n    try {\n      promiseOrValue = initialPromise ?? config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {\n      if (isResolved) {\n        return;\n      }\n      const retry = config.retry ?? (isServer ? 0 : 3);\n      const retryDelay = config.retryDelay ?? defaultRetryDelay;\n      const delay = typeof retryDelay === \"function\" ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === \"number\" && failureCount < retry || typeof retry === \"function\" && retry(failureCount, error);\n      if (isRetryCancelled || !shouldRetry) {\n        reject(error);\n        return;\n      }\n      failureCount++;\n      config.onFail?.(failureCount, error);\n      sleep(delay).then(() => {\n        return canContinue() ? void 0 : pause();\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  };\n  return {\n    promise: thenable,\n    cancel,\n    continue: () => {\n      continueFn?.();\n      return thenable;\n    },\n    cancelRetry,\n    continueRetry,\n    canStart,\n    start: () => {\n      if (canStart()) {\n        run();\n      } else {\n        pause().then(run);\n      }\n      return thenable;\n    }\n  };\n}\nexport {\n  CancelledError,\n  canFetch,\n  createRetryer,\n  isCancelledError\n};\n//# sourceMappingURL=retryer.js.map","// src/subscribable.ts\nvar Subscribable = class {\n  constructor() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.subscribe = this.subscribe.bind(this);\n  }\n  subscribe(listener) {\n    this.listeners.add(listener);\n    this.onSubscribe();\n    return () => {\n      this.listeners.delete(listener);\n      this.onUnsubscribe();\n    };\n  }\n  hasListeners() {\n    return this.listeners.size > 0;\n  }\n  onSubscribe() {\n  }\n  onUnsubscribe() {\n  }\n};\nexport {\n  Subscribable\n};\n//# sourceMappingURL=subscribable.js.map","// src/thenable.ts\nfunction pendingThenable() {\n  let resolve;\n  let reject;\n  const thenable = new Promise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  thenable.status = \"pending\";\n  thenable.catch(() => {\n  });\n  function finalize(data) {\n    Object.assign(thenable, data);\n    delete thenable.resolve;\n    delete thenable.reject;\n  }\n  thenable.resolve = (value) => {\n    finalize({\n      status: \"fulfilled\",\n      value\n    });\n    resolve(value);\n  };\n  thenable.reject = (reason) => {\n    finalize({\n      status: \"rejected\",\n      reason\n    });\n    reject(reason);\n  };\n  return thenable;\n}\nexport {\n  pendingThenable\n};\n//# sourceMappingURL=thenable.js.map","// src/utils.ts\nvar isServer = typeof window === \"undefined\" || \"Deno\" in globalThis;\nfunction noop() {\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === \"function\" ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === \"number\" && value >= 0 && value !== Infinity;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction resolveStaleTime(staleTime, query) {\n  return typeof staleTime === \"function\" ? staleTime(query) : staleTime;\n}\nfunction resolveEnabled(enabled, query) {\n  return typeof enabled === \"function\" ? enabled(query) : enabled;\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = \"all\",\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n  if (queryKey) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n  if (type !== \"all\") {\n    const isActive = query.isActive();\n    if (type === \"active\" && !isActive) {\n      return false;\n    }\n    if (type === \"inactive\" && isActive) {\n      return false;\n    }\n  }\n  if (typeof stale === \"boolean\" && query.isStale() !== stale) {\n    return false;\n  }\n  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const { exact, status, predicate, mutationKey } = filters;\n  if (mutationKey) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n    if (exact) {\n      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n  if (status && mutation.state.status !== status) {\n    return false;\n  }\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = options?.queryKeyHashFn || hashKey;\n  return hashFn(queryKey);\n}\nfunction hashKey(queryKey) {\n  return JSON.stringify(\n    queryKey,\n    (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n      result[key] = val[key];\n      return result;\n    }, {}) : val\n  );\n}\nfunction partialMatchKey(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    return !Object.keys(b).some((key) => !partialMatchKey(a[key], b[key]));\n  }\n  return false;\n}\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n  const array = isPlainArray(a) && isPlainArray(b);\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aItems = array ? a : Object.keys(a);\n    const aSize = aItems.length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      if ((!array && aItems.includes(key) || array) && a[key] === void 0 && b[key] === void 0) {\n        copy[key] = void 0;\n        equalItems++;\n      } else {\n        copy[key] = replaceEqualDeep(a[key], b[key]);\n        if (copy[key] === a[key] && a[key] !== void 0) {\n          equalItems++;\n        }\n      }\n    }\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n  return b;\n}\nfunction shallowEqualObjects(a, b) {\n  if (!b || Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n}\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  }\n  const ctor = o.constructor;\n  if (ctor === void 0) {\n    return true;\n  }\n  const prot = ctor.prototype;\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  }\n  if (!prot.hasOwnProperty(\"isPrototypeOf\")) {\n    return false;\n  }\n  if (Object.getPrototypeOf(o) !== Object.prototype) {\n    return false;\n  }\n  return true;\n}\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === \"[object Object]\";\n}\nfunction sleep(timeout) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeout);\n  });\n}\nfunction replaceData(prevData, data, options) {\n  if (typeof options.structuralSharing === \"function\") {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    if (process.env.NODE_ENV !== \"production\") {\n      try {\n        return replaceEqualDeep(prevData, data);\n      } catch (error) {\n        console.error(\n          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${options.queryHash}]: ${error}`\n        );\n      }\n    }\n    return replaceEqualDeep(prevData, data);\n  }\n  return data;\n}\nfunction keepPreviousData(previousData) {\n  return previousData;\n}\nfunction addToEnd(items, item, max = 0) {\n  const newItems = [...items, item];\n  return max && newItems.length > max ? newItems.slice(1) : newItems;\n}\nfunction addToStart(items, item, max = 0) {\n  const newItems = [item, ...items];\n  return max && newItems.length > max ? newItems.slice(0, -1) : newItems;\n}\nvar skipToken = Symbol();\nfunction ensureQueryFn(options, fetchOptions) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (options.queryFn === skipToken) {\n      console.error(\n        `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${options.queryHash}'`\n      );\n    }\n  }\n  if (!options.queryFn && fetchOptions?.initialPromise) {\n    return () => fetchOptions.initialPromise;\n  }\n  if (!options.queryFn || options.queryFn === skipToken) {\n    return () => Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));\n  }\n  return options.queryFn;\n}\nexport {\n  addToEnd,\n  addToStart,\n  ensureQueryFn,\n  functionalUpdate,\n  hashKey,\n  hashQueryKeyByOptions,\n  isPlainArray,\n  isPlainObject,\n  isServer,\n  isValidTimeout,\n  keepPreviousData,\n  matchMutation,\n  matchQuery,\n  noop,\n  partialMatchKey,\n  replaceData,\n  replaceEqualDeep,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  skipToken,\n  sleep,\n  timeUntilStale\n};\n//# sourceMappingURL=utils.js.map","'use client'\nimport * as React from 'react'\n\nimport type { QueryClient } from '@tanstack/query-core'\n\nexport const QueryClientContext = React.createContext<QueryClient | undefined>(\n  undefined,\n)\n\nexport const useQueryClient = (queryClient?: QueryClient) => {\n  const client = React.useContext(QueryClientContext)\n\n  if (queryClient) {\n    return queryClient\n  }\n\n  if (!client) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return client\n}\n\nexport type QueryClientProviderProps = {\n  client: QueryClient\n  children?: React.ReactNode\n}\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n}: QueryClientProviderProps): React.JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  return (\n    <QueryClientContext.Provider value={client}>\n      {children}\n    </QueryClientContext.Provider>\n  )\n}\n","'use client'\nimport * as React from 'react'\n\n// CONTEXT\nexport type QueryErrorResetFunction = () => void\nexport type QueryErrorIsResetFunction = () => boolean\nexport type QueryErrorClearResetFunction = () => void\n\nexport interface QueryErrorResetBoundaryValue {\n  clearReset: QueryErrorClearResetFunction\n  isReset: QueryErrorIsResetFunction\n  reset: QueryErrorResetFunction\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport type QueryErrorResetBoundaryFunction = (\n  value: QueryErrorResetBoundaryValue,\n) => React.ReactNode\n\nexport interface QueryErrorResetBoundaryProps {\n  children: QueryErrorResetBoundaryFunction | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function' ? children(value) : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n","'use client'\nimport * as React from 'react'\nimport { shouldThrowError } from './utils'\nimport type {\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserverResult,\n  ThrowOnError,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const ensurePreventErrorBoundaryRetry = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  if (\n    options.suspense ||\n    options.throwOnError ||\n    options.experimental_prefetchInRender\n  ) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false\n    }\n  }\n}\n\nexport const useClearResetErrorBoundary = (\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n}\n\nexport const getHasError = <\n  TData,\n  TError,\n  TQueryFnData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>({\n  result,\n  errorResetBoundary,\n  throwOnError,\n  query,\n}: {\n  result: QueryObserverResult<TData, TError>\n  errorResetBoundary: QueryErrorResetBoundaryValue\n  throwOnError: ThrowOnError<TQueryFnData, TError, TQueryData, TQueryKey>\n  query: Query<TQueryFnData, TError, TQueryData, TQueryKey> | undefined\n}) => {\n  return (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    query &&\n    shouldThrowError(throwOnError, [result.error, query])\n  )\n}\n","'use client'\nimport * as React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n","// src/suspense.ts\nvar defaultThrowOnError = (_error, query) => query.state.data === void 0;\nvar ensureSuspenseTimers = (defaultedOptions) => {\n  if (defaultedOptions.suspense) {\n    if (defaultedOptions.staleTime === void 0) {\n      defaultedOptions.staleTime = 1e3;\n    }\n    if (typeof defaultedOptions.gcTime === \"number\") {\n      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1e3);\n    }\n  }\n};\nvar willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;\nvar shouldSuspend = (defaultedOptions, result) => defaultedOptions?.suspense && result.isPending;\nvar fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {\n  errorResetBoundary.clearReset();\n});\nexport {\n  defaultThrowOnError,\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch\n};\n//# sourceMappingURL=suspense.js.map","'use client'\nimport * as React from 'react'\n\nimport { isServer, notifyManager } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport { useIsRestoring } from './isRestoring'\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch,\n} from './suspense'\nimport { noop } from './utils'\nimport type {\n  QueryClient,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { UseBaseQueryOptions } from './types'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n  queryClient?: QueryClient,\n): QueryObserverResult<TData, TError> {\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof options !== 'object' || Array.isArray(options)) {\n      throw new Error(\n        'Bad argument type. Starting with v5, only the \"Object\" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object',\n      )\n    }\n  }\n\n  const client = useQueryClient(queryClient)\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const defaultedOptions = client.defaultQueryOptions(options)\n\n  ;(client.getDefaultOptions().queries as any)?._experimental_beforeQuery?.(\n    defaultedOptions,\n  )\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  ensureSuspenseTimers(defaultedOptions)\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary)\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  // this needs to be invoked before creating the Observer because that can create a cache entry\n  const isNewCacheEntry = !client\n    .getQueryCache()\n    .get(defaultedOptions.queryHash)\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        client,\n        defaultedOptions,\n      ),\n  )\n\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = isRestoring\n          ? noop\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange))\n\n        // Update result to make sure we did not miss any query updates\n        // between creating the observer and subscribing to it.\n        observer.updateResult()\n\n        return unsubscribe\n      },\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, { listeners: false })\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (shouldSuspend(defaultedOptions, result)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n  }\n\n  // Handle error boundary\n  if (\n    getHasError({\n      result,\n      errorResetBoundary,\n      throwOnError: defaultedOptions.throwOnError,\n      query: client\n        .getQueryCache()\n        .get<\n          TQueryFnData,\n          TError,\n          TQueryData,\n          TQueryKey\n        >(defaultedOptions.queryHash),\n    })\n  ) {\n    throw result.error\n  }\n\n  ;(client.getDefaultOptions().queries as any)?._experimental_afterQuery?.(\n    defaultedOptions,\n    result,\n  )\n\n  if (\n    defaultedOptions.experimental_prefetchInRender &&\n    !isServer &&\n    willFetch(result, isRestoring)\n  ) {\n    const promise = isNewCacheEntry\n      ? // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted\n        fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n      : // subscribe to the \"cache promise\" so that we can finalize the currentThenable once data comes in\n        client.getQueryCache().get(defaultedOptions.queryHash)?.promise\n\n    promise?.catch(noop).finally(() => {\n      // `.updateResult()` will trigger `.#currentThenable` to finalize\n      observer.updateResult()\n    })\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n","'use client'\nimport { QueryObserver } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type { DefaultError, QueryClient, QueryKey } from '@tanstack/query-core'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\nimport type {\n  DefinedInitialDataOptions,\n  UndefinedInitialDataOptions,\n} from './queryOptions'\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseQueryResult<TData, TError>\n\nexport function useQuery(options: UseQueryOptions, queryClient?: QueryClient) {\n  return useBaseQuery(options, QueryObserver, queryClient)\n}\n","// src/utils.ts\nfunction shouldThrowError(throwError, params) {\n  if (typeof throwError === \"function\") {\n    return throwError(...params);\n  }\n  return !!throwError;\n}\nfunction noop() {\n}\nexport {\n  noop,\n  shouldThrowError\n};\n//# sourceMappingURL=utils.js.map"],"names":["focusManager","_subscribable_js__WEBPACK_IMPORTED_MODULE_0__","l","focused","cleanup","setup","_utils_js__WEBPACK_IMPORTED_MODULE_1__","sk","window","addEventListener","listener","onFocus","removeEventListener","onSubscribe","setEventListener","onUnsubscribe","hasListeners","setFocused","isFocused","listeners","forEach","globalThis","document","visibilityState","notifyManager","createNotifyManager","queue","transactions","notifyFn","callback","batchNotifyFn","scheduleFn","setTimeout","cb","schedule","push","flush","originalQueue","length","batch","result","batchCalls","args","setNotifyFunction","fn","setBatchNotifyFunction","setScheduler","onlineManager","online","onlineListener","onOnline","offlineListener","setOnline","bind","isOnline","Query","_removable_js__WEBPACK_IMPORTED_MODULE_0__","F","initialState","revertState","cache","retryer","defaultOptions","abortSignalConsumed","config","setOptions","options","observers","queryKey","queryHash","getDefaultState","data","initialData","hasData","initialDataUpdatedAt","dataUpdateCount","dataUpdatedAt","Date","now","error","errorUpdateCount","errorUpdatedAt","fetchFailureCount","fetchFailureReason","fetchMeta","isInvalidated","status","fetchStatus","state","scheduleGc","meta","promise","updateGcTime","gcTime","optionalRemove","remove","setData","newData","oE","dispatch","type","updatedAt","manual","setState","setStateOptions","cancel","then","ZT","catch","Promise","resolve","destroy","silent","reset","isActive","some","Nc","observer","enabled","isDisabled","getObserversCount","queryFn","CN","isStale","getCurrentResult","isStaleByTime","staleTime","Kp","find","x","shouldFetchOnWindowFocus","refetch","cancelRefetch","continue","shouldFetchOnReconnect","addObserver","includes","clearGcTimeout","notify","query","removeObserver","filter","revert","cancelRetry","invalidate","fetch","fetchOptions","continueRetry","abortController","AbortController","addSignalProperty","Object","defineProperty","object","enumerable","get","signal","context","fetchFn","cG","queryFnContext","persister","behavior","onFetch","onError","_retryer_js__WEBPACK_IMPORTED_MODULE_2__","DV","onSettled","Mz","initialPromise","abort","onSuccess","onFail","failureCount","onPause","onContinue","retry","retryDelay","networkMode","canRun","start","action","reducer","fetchState","_notifyManager_js__WEBPACK_IMPORTED_MODULE_3__","V","onQueryUpdate","Kw","QueryObserver","constructor","client","selectError","currentThenable","_thenable_js__WEBPACK_IMPORTED_MODULE_1__","O","experimental_prefetchInRender","reject","bindMethods","currentQuery","currentQueryInitialState","currentResult","currentResultState","currentResultOptions","selectFn","selectResult","lastQueryWithDefinedData","staleTimeoutId","refetchIntervalId","currentRefetchInterval","trackedProps","Set","size","shouldFetchOnMount","executeFetch","updateResult","updateTimers","shouldFetchOn","refetchOnReconnect","refetchOnWindowFocus","clearStaleTimeout","clearRefetchInterval","notifyOptions","prevOptions","prevQuery","defaultQueryOptions","_utils_js__WEBPACK_IMPORTED_MODULE_2__","updateQuery","_defaulted","VS","getQueryCache","mounted","shouldFetchOptionally","KC","updateStaleTimeout","nextRefetchInterval","computeRefetchInterval","updateRefetchInterval","getOptimisticResult","build","createResult","trackResult","onPropTracked","trackedResult","keys","key","configurable","trackProp","add","getCurrentQuery","fetchOptimistic","defaultedOptions","throwOnError","PN","time","refetchInterval","nextInterval","setInterval","refetchIntervalInBackground","_focusManager_js__WEBPACK_IMPORTED_MODULE_3__","j","clearTimeout","clearInterval","prevResult","prevResultState","prevResultOptions","queryInitialState","queryChange","newState","isPlaceholderData","_optimisticResults","fetchOnMount","fetchOptionally","_query_js__WEBPACK_IMPORTED_MODULE_4__","z","select","placeholderData","isFetching","isPending","isError","isLoading","isSuccess","isInitialLoading","failureReason","isFetched","isFetchedAfterMount","isRefetching","isLoadingError","isPaused","isRefetchError","finalizeThenableIfPossible","nextResult","thenable","recreateThenable","prevThenable","value","reason","defaultNotifyOptions","shouldNotifyListeners","notifyOnChangeProps","notifyOnChangePropsValue","includedProps","changed","has","_notifyManager_js__WEBPACK_IMPORTED_MODULE_5__","retryOnMount","refetchOnMount","field","suspense","Removable","gcTimeout","_utils_js__WEBPACK_IMPORTED_MODULE_0__","newGcTime","Math","max","Infinity","defaultRetryDelay","min","canFetch","_onlineManager_js__WEBPACK_IMPORTED_MODULE_0__","N","CancelledError","Error","isCancelledError","createRetryer","continueFn","isRetryCancelled","isResolved","canContinue","_focusManager_js__WEBPACK_IMPORTED_MODULE_2__","canStart","pause","continueResolve","run","promiseOrValue","_utils_js__WEBPACK_IMPORTED_MODULE_3__","delay","shouldRetry","_v","cancelOptions","Subscribable","subscribe","delete","pendingThenable","_resolve","_reject","finalize","assign","isServer","noop","functionalUpdate","updater","input","isValidTimeout","timeUntilStale","resolveStaleTime","resolveEnabled","matchQuery","filters","exact","predicate","stale","hashQueryKeyByOptions","partialMatchKey","matchMutation","mutation","mutationKey","hashKey","hashFn","queryKeyHashFn","JSON","stringify","_","val","isPlainObject","sort","reduce","a","b","replaceEqualDeep","array","isPlainArray","aItems","aSize","bItems","bSize","copy","equalItems","i","shallowEqualObjects","Array","isArray","o","hasObjectPrototype","ctor","prot","prototype","hasOwnProperty","getPrototypeOf","toString","call","sleep","timeout","replaceData","prevData","structuralSharing","addToEnd","items","item","newItems","slice","addToStart","skipToken","Symbol","ensureQueryFn","QueryClientContext","React","useQueryClient","queryClient","QueryClientProvider","children","param","mount","unmount","jsx","Provider","createValue","isReset","clearReset","QueryErrorResetBoundaryContext","useQueryErrorResetBoundary","QueryErrorResetBoundary","ensurePreventErrorBoundaryRetry","errorResetBoundary","useClearResetErrorBoundary","getHasError","shouldThrowError","IsRestoringContext","useIsRestoring","IsRestoringProvider","defaultThrowOnError","_error","ensureSuspenseTimers","willFetch","isRestoring","shouldSuspend","useBaseQuery","Observer","getDefaultOptions","queries","_experimental_beforeQuery","isNewCacheEntry","unsubscribe","onStoreChange","_experimental_afterQuery","finally","useQuery","throwError","params"],"sourceRoot":""}